{"meta":{"title":"唯梦依癸的博客","subtitle":"","description":"Jcm","author":"JCM","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2023-02-06T08:50:36.321Z","updated":"2023-02-06T08:50:36.321Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"about","date":"2023-02-06T02:14:40.000Z","updated":"2023-02-06T02:24:01.449Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2023-02-06T02:25:57.749Z","updated":"2023-02-06T02:25:57.749Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"所有分类","date":"2023-02-06T02:30:40.378Z","updated":"2023-02-06T02:30:40.378Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-02-06T02:25:25.705Z","updated":"2023-02-06T02:25:25.705Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式","slug":"设计模式","date":"2023-02-22T11:05:56.000Z","updated":"2023-02-22T15:46:21.681Z","comments":true,"path":"2023/02/22/设计模式/","link":"","permalink":"http://example.com/2023/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式(23种) 一：单例模式。 GoF中定义： “确认类只有一个对象，并提供一个全局的方法来获取这个对象” 使用单例模式的前提： 它只能产生一个对象且不能够被继承 单例模式的优点： 1.提供方便获取唯一对象的方法 2.可以限制对象的产生数量 单例模式的缺点： 1.容易造成设计思考不周和过度使用的问题 2.违反了“开-闭原则”（OCP） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using System;using System.Collections;using System.Collections.Generic;using UnityEngine;/* * 单例： * 实例全局唯一 * static 属于全局，并不属于类对象本身 * 实例只能在类的内部发生 * 需要将构造函数私有化 * 需要提供一个供外部访问的变量 */public class MySingleton&#123; //构造函数 private MySingleton() &#123; Debug.Log(&quot;构造函数执行&quot;); &#125; private static MySingleton _instance; //static字段 public static MySingleton Instance //类似于属性 &#123; get &#123; if(_instance == null) //不用set赋给字段值，在get里面直接赋值，就会执行构造函数，然后就是唯一的 &#123; _instance = new MySingleton(); &#125; return _instance; &#125; &#125; public void Show() &#123; Debug.Log(&quot;Show&quot;); &#125;&#125;public class HelloWorld : MonoBehaviour&#123; void Start() &#123; MySingleton single1 = MySingleton.Instance; single1.Show(); MySingleton single2 = MySingleton.Instance; single2.Show(); //根据输出的HashCode发现是相同的，推断出实例全局是唯一的 Debug.Log(&quot;single1=&quot;+single1.GetHashCode()+&quot;single2=&quot;+single2.GetHashCode()); &#125; void Update() &#123; &#125;&#125; 二：观察者模式。 GoF中定义： “在对象之间定义一个一对多的连接方法，当一个对象变换状态时，其他关联的对象都会自动收到通知。” 现实中，社交网络就是个例子。 以前的报社，每次出新刊的时候， 报刊便会将新刊一本一本的送到订阅报刊人的手中 于是，每次出新刊，报社都得送到每个人的手中 而如今的微博，便是应用了观察者模式 当想关注某个人时，只需要点击关注便可订阅 当关注的人更新微博时，只需要更新到微博平台 订阅的人就可以接收到更新的消息 而不需要被关注的那个人向每个订阅者发送消息 C#中的事件系统（Event）便是使用的观察者模式 Unity中的所有事件（如UI点击事件）也是应用的观察者模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.Animations;/* * 观察者模式 * 需求：野猫来了，老鼠A B C 惊吓逃走 * * * * *///父类public class Animal&#123; public Animal(string name) &#123; this.Name= name; &#125; protected string Name &#123; get; set; &#125; //自动属性 public virtual void Run() &#123; &#125;&#125;public class Cat : Animal&#123; public event Action actions; //事件发布者 public Cat(string name):base(name) &#123; &#125; public void Coming() &#123; Debug.Log(Name+&quot;来了&quot;); if(actions!= null) &#123; actions();//通过多播委托或事件完成一对多的关系，这里的actions已经在Mouse类中添加了不少订阅者 &#125; this.Run(); &#125; public override void Run() &#123; Debug.Log(Name+&quot;开始追三只老鼠&quot;); &#125;&#125;public class Mouse : Animal&#123; public Mouse(string name,Cat cat) : base(name) &#123; cat.actions += this.Run; //订阅者，在Cat的actions的委托中添加老鼠逃跑的方法 &#125; public override void Run() &#123; Debug.Log(Name + &quot;逃跑&quot;); &#125;&#125;public class HelloWorld : MonoBehaviour&#123; void Start() &#123; Cat cat = new Cat(&quot;小野喵&quot;); //每新建一个mouse对象，都会在Cat的事件actions中添加老鼠的Run方法 Animal mouseA = new Mouse(&quot;mouseA&quot;,cat); Animal mouseB = new Mouse(&quot;mouseB&quot;,cat); Animal mouseC = new Mouse(&quot;mouseC&quot;,cat); cat.Coming(); //运行并输出actions多播委托中的方法 &#125; void Update() &#123; &#125;&#125; 观察者模式的设计原理是，先设置一个主题（Subject） 让这个主题发布时可同时通知关心这个主题的观察者&#x2F;订阅者 并且主题不必理会观察者&#x2F;订阅者接下来会执行哪些操作 观察者模式的主要功能和优点： 将“主题发生”与“功能执行”这两个操作解除绑定 三：简单工厂模式。 1.简单工厂模式和普通工厂的区别：（1）普通工厂是通过父类定义为抽象类，然后将子类赋给父类对象中创建对象的。 （2）而简单工厂模式，是要通过一个中间件(工厂类)，间接进行对象的产生。 2.实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//鼠标抽象类public abstract class Mouse&#123; public abstract void Print();&#125;//戴尔鼠标public class DellMouse : Mouse&#123; public override void Print() &#123; Console.WriteLine(&quot;生产了一个Dell鼠标！&quot;); &#125;&#125;//惠普鼠标public class HpMouse : Mouse&#123; public override void Print() &#123; Console.WriteLine(&quot;生产了一个惠普鼠标！&quot;); &#125;&#125;//使用枚举来举例生成对应的对象public enum MouseType&#123; None, DellMouse, HpMouse,&#125;-------------工厂类------------/// &lt;summary&gt;/// 鼠标工厂类，中间件/// &lt;/summary&gt;public class MouseFactory&#123; private Mouse mouse = null; public Mouse CreateMouse(MouseType emMouseType) &#123; switch (emMouseType) &#123; case MouseType.DellMouse: mouse = new DellMouse(); break; case MouseType.HpMouse: mouse = new HpMouse(); break; /*增加新产品时，需要修改中间件的简单工厂类，这就违反了开闭原则 case MouseType.HpMouse: mouse = new HpMouse(); break; */ default: break; &#125; return mouse; &#125;&#125;-------------Main中------------class Program&#123; static void Main(string[] args) &#123; //实例化一个工厂类 MouseFactory mouseFactory = new MouseFactory(); //通过工厂类创建鼠标 Mouse mouse1 = mouseFactory.CreateMouse(MouseType.DellMouse); mouse1.Print(); Console.ReadKey(); &#125;&#125; 3.简单工厂模式的优缺点。简单工厂模式的优点： ​ (1)简单工厂可以有效地降低客户端和具体对象的耦合，将new具体对象的任务交给了一个简单工厂类 (2)可以有效的进行代码复用，如客户端A和客户端B都需要一个具体对象，客户端A和客户端B可以通过同一个简单工厂来获取具体类型的实例 简单工厂模式的缺点： 一定程度上违背了开闭原则，即在新增产品时需要修改简单工厂类 四：工厂模式。(为了解决简单工厂的问题) 1.工厂模式和简单工厂模式的区别：（1）解决了简单工厂模式的违反开闭原则，因为中间件在简单工厂模式中只是一个接口。 （2）根据这个接口，再产生对应的中间件。 （3）因此，若是新添产品，只需要根据工厂中间件的接口产生对应的中间件即可。 2.实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//鼠标抽象类public abstract class Mouse&#123; public abstract void Print();&#125;//戴尔鼠标public class DellMouse : Mouse&#123; public override void Print() &#123; Console.WriteLine(&quot;生产了一个Dell鼠标！&quot;); &#125;&#125;//惠普鼠标public class HpMouse : Mouse&#123; public override void Print() &#123; Console.WriteLine(&quot;生产了一个惠普鼠标！&quot;); &#125;&#125;//新增的苹果鼠标public class AppleMouse : Mouse&#123; public override void Print() &#123; Console.WriteLine(&quot;生产了一个苹果鼠标！&quot;); &#125;&#125;-------------工厂类------------/// &lt;summary&gt;/// 鼠标工厂抽象类，这里作为抽象类使用，只需要让子类中间件重写方法；因此，如果新增产品，也不会改变工厂类内容，遵循了开闭原则/// &lt;/summary&gt;public abstract class MouseFactory&#123; public abstract Mouse CreateMouse();&#125;//戴尔鼠标工厂，重写了鼠标工厂的方法public class DellMouseFactroy : MouseFactory&#123; public override Mouse CreateMouse() &#123; return new DellMouse();//在具体的工厂中实例化产品 &#125;&#125;//惠普鼠标工厂，重写了鼠标工厂的方法public class HpMouseFactory : MouseFactory&#123; public override Mouse CreateMouse() &#123; return new HpMouse();//在具体的工厂中实例化产品 &#125;&#125;//新增的苹果鼠标工厂，重写了鼠标工厂的方法public class AppleMouseFactory : MouseFactory&#123; public override Mouse CreateMouse() &#123; return new AppleMouse();//在具体的工厂中实例化产品 &#125;&#125;-------------Main中------------static void Main(string[] args)&#123; //生产一个戴尔鼠标 MouseFactory dellMouseFactory = new DellMouseFactroy(); Mouse dellMouse= dellMouseFactory.CreateMouse(); dellMouse.Print(); //生产一个惠普鼠标 MouseFactory hpMouseFactory = new HpMouseFactory(); Mouse hpMouse = hpMouseFactory.CreateMouse(); hpMouse.Print(); Console.ReadKey(); //生产一个苹果鼠标 MouseFactory appleMouseFactory = new AppleMouseFactory(); Mouse appleMouse = AppleMouseFactory.CreateMouse(); appleMouse.Print();&#125; 3.工厂模式的优缺点。工厂模式的优点： 工厂模式有效地解决了添加新产品必须要修改工厂类代码的问题，符合设计原则中的开闭原则。 工厂模式的缺点： 工厂模式的本质是将具体实例的创建工作放在了具体子类工厂中进行，这造成一个新的问题：将选择实例类型的任务交给了客户端，如我们想生产一个戴尔鼠标，就必须在客户端new一个戴尔鼠标工厂。想象下如果我们new了100个戴尔鼠标工厂，这是要换到惠普鼠标怎么办？只能把new DellMouseFactory一个一个地替换成new HpMouseFactory。所以简单工厂和工厂模式都不是完美的，我们应该根据具体的情况来选择。 五：抽象工厂模式。 1.抽象工厂模式和工厂模式的区别：（1）抽象工厂模式是为了解决生产多种产品的问题。 （2）而工厂模式只能生产一种产品。 （3）所以也可以说，工厂模式可以看作是抽象工厂模式的一个特例。 2.实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//鼠标抽象类public abstract class Mouse&#123; public abstract void Print();&#125;//戴尔鼠标public class DellMouse : Mouse&#123; public override void Print() &#123; Console.WriteLine(&quot;生产了一个Dell鼠标！&quot;); &#125;&#125;//惠普鼠标public class HpMouse : Mouse&#123; public override void Print() &#123; Console.WriteLine(&quot;生产了一个惠普鼠标！&quot;); &#125;&#125;//键盘抽象类(相比工厂模式，新增的抽象父类)public abstract class Keybo&#123; public abstract void Print();&#125;//戴尔键盘类public class DellKeybo : Keybo&#123; public override void Print() &#123; Console.WriteLine(&quot;生产了一个戴尔键盘！&quot;); &#125;&#125;//惠普键盘public class HpKeybo : Keybo&#123; public override void Print() &#123; Console.WriteLine(&quot;生产了一个惠普键盘！&quot;); &#125;&#125;-------------工厂类------------ /// &lt;summary&gt; /// Pc产品工厂抽象类，相比工厂模式，就是里面多了一种产品的抽象类 /// &lt;/summary&gt; public abstract class PcFactory &#123; public abstract Mouse CreateMouse(); public abstract Keybo CreateKeybo(); &#125;//戴尔pc工厂，相比工厂模式，就是里面多了一种产品需要重写public class DellPcFactroy : PcFactory&#123; public override Keybo CreateKeybo() &#123; return new DellKeybo(); &#125; public override Mouse CreateMouse() &#123; return new DellMouse(); &#125;&#125;//惠普pc工厂，相比工厂模式，就是里面多了一种产品需要重写public class HpPcFactory : PcFactory&#123; public override Mouse CreateMouse() &#123; return new HpMouse(); &#125; public override Keybo CreateKeybo() &#123; return new HpKeybo(); &#125;&#125;-------------Main中------------class Program&#123; static void Main(string[] args) &#123; //生产一个戴尔鼠标/键盘 PcFactory dellFactory = new DellPcFactroy(); Mouse dellMouse= dellFactory.CreateMouse(); Keybo dellKeybo = dellFactory.CreateKeybo(); dellMouse.Print(); dellKeybo.Print(); //生产一个惠普鼠标/键盘 PcFactory hpFactory = new HpPcFactory(); Mouse hpMouse = hpFactory.CreateMouse(); Keybo hpKeybo = hpFactory.CreateKeybo(); hpMouse.Print(); hpKeybo.Print(); Console.ReadKey(); &#125;&#125; 3.抽象工厂模式的优缺点。 抽象工厂模式的优点： ​ 抽象工厂具有工厂模式的优点，对添加系列产品符合闭合原则（工厂模式的系列产品只有一种，但不符合开原则）。如要生产华硕的鼠标和键盘，只需要添加一个AsusPcFactory（继承与PcFactory），AsusMouse(继承Mouse),AsusKeybo(继承Keybo)，就可以在客户端通过以下代码生产华硕鼠标和键盘： 123PcFactory asusPcFactory=new AsusPcFactory();asusPcFactory.CreateMouse();//生产华硕鼠标asusPcFactory.CreaetKeybo();//生产华硕键盘 抽象工厂模式的缺点： ​ 抽象模式对添加新产品不符合开闭原则(因为需要修改工厂类)。如要生产显示器，不仅要添加显示器抽象类和显示器具体类，还需要修改PcFactory(工厂类),在抽象工厂中添加一个CreateDisplay抽象方法（或接口），戴尔工厂和惠普工厂也要实现新增的抽象方法(或者接口）。 六：适配器模式。 1.适配器模式介绍。适配器模式的作用是将一个类的接口，转换成客户端希望的另外一种接口，适配器作为原始接口（我们的类中本来具有的功能）和目标接口（客户端希望的功能）之间的桥梁。举个例子：我们知道安卓数据线是不能给苹果手机充电的，但是我们没有苹果数据线，所以只能使用安卓数据线给苹果手机充电，这时怎么解决呢？通过一个转换头就可以了，这个转换头就是一个适配器。在适配器模式中：安卓数据线是我们现有的类，充电是安卓数据线的功能，但是充电功能就是因为接口不兼容所以不适应新环境（给苹果手机充电），转换头作为苹果手机和安卓数据线之间的桥梁，让原有的充电功能使用于新环境（给苹果手机充电）。 适配器模式有两种类型：类适配器和对象适配器，类适配器通过多重继承实现接口的匹配，C#不支持多重继承，我们不考虑。我们主要介绍对象适配器。首先说明介绍适配器模式的三个角色： （1）Adaptee:初始角色，实现了我们想要使用的功能，但是接口不匹配 （2）Target:目标角色，定义了客户端期望的接口 （3）Adapter:适配器角色，实现了目标接口。实现目标接口的方法是：内部包含一个Adaptee的对象，通过这个对象调用Adaptee的原有方法实现目标接口。（注：这里说的是对象适配器） 2.实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/// &lt;summary&gt;/// 安卓数据线，adaptee角色/// &lt;/summary&gt;public class AndroidLine&#123; public void AndroidCharge() &#123; Console.WriteLine(&quot;安卓数据线充电....&quot;); &#125;&#125;/// &lt;summary&gt;/// 苹果数据线，adaptee角色/// &lt;/summary&gt;public class AppleLine&#123; public void AppleCharge() &#123; Console.WriteLine(&quot;苹果数据线充电....&quot;); &#125;&#125;//枚举来声明充电接口public enum AdaptorType&#123; None, Android, Ios,&#125;/// &lt;summary&gt;/// 充电接口，目标接口，可以统一调用接口/// &lt;/summary&gt;public interface IApplyCharge&#123; void ApplyChange(AdaptorType adaptorType);&#125;/// &lt;summary&gt;/// 我们想要苹果能够使用安卓的充电线充电，就需要创建一个适配器/// &lt;/summary&gt;public class ApplyAdapter : IApplyCharge //使用接口，易于拓展原始类不同的功能&#123; AndroidLine androidLine = new AndroidLine();//适配器内部包含一个Adaptee对象 AppleLine appleLine = new AppleLine(); public void ApplyChange(AdaptorType adaptorType) //在苹果接口中调用安卓的充电方法 &#123; if(adaptorType=AdaptorType.Android)&#123; androidLine.AndroidCharge();//客户端调用时，表面上是用的是ApplyChange方法,本质还是用的AndroidCharge方法 &#125; else if(adaptorType=AdaptorType.Ios)&#123; appleLine.AppleCharge(); &#125; &#125;&#125;-------------Main中------------class Program&#123; static void Main(string[] args) &#123; //获取一个target的实例 IApplyCharge applyAdapter = new ApplyAdapter(); applyAdapter.ApplyChange(AdaptorType.Android);//表面上用的苹果充电方法ApplyChange，本质上还是用的安卓充电方法AndriodChange。 applyAdapter.ApplyChange(AdaptorType.Ios); //调用苹果的充电 Console.ReadKey(); &#125;&#125; 3.适配器模式使用创建和优缺点。适配器的使用场景： 系统想使用一个类，但是这个类的接口不符合系统的要求时使用适配器模式。 适配器模式的优点： (1)提高代码复用，复用了Adaptee中的方法。 (2)灵活性好，如没有关联的两个类A和类B，类A想借用类B的方法，可以在类A中添加一个类B的实例，然后调用类B实例的方法即可。 适配器模式的缺点： 过多使用适配器会让十分凌乱，如我们明明调用的是A接口的功能，但是却被适配成了B接口的功能。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"JCM"},{"title":"c#笔记day12-委托与事件","slug":"c-笔记day12","date":"2023-02-21T12:39:02.000Z","updated":"2023-02-21T11:48:24.629Z","comments":true,"path":"2023/02/21/c-笔记day12/","link":"","permalink":"http://example.com/2023/02/21/c-%E7%AC%94%E8%AE%B0day12/","excerpt":"","text":"c#笔记第十二天一：委托。(引用类型)1.委托的定义和使用。 12345678910111213141516171819202122232425262728293031323334353637383940414243using System.Collections;using System.Collections.Generic;using UnityEngine;public class HelloWorld : MonoBehaviour&#123; public delegate void ShowDelegate(); public delegate void ShowDelegate2(int a,int b); public delegate void ShowDelegate3&lt;T&gt; (T a); //泛型委托定义，前面加&lt;T&gt;，后面参数中才能使用T，T可以用任意类型代替 // Start is called before the first frame update void Start() &#123; ShowDelegate show1 = Show1; //delegate里面装的是函数，对应函数的参数要和delegate的参数一致 show1.Invoke(); ShowDelegate2 show2 = Show2; show2.Invoke(1,2); ShowDelegate3&lt;string&gt; show3 = Show3; show3.Invoke(&quot;Hello World!&quot;); &#125; // Update is called once per frame void Update() &#123; &#125; private void Show1() &#123; Debug.Log(&quot;Show1&quot;); &#125; private void Show2(int a,int b) &#123; Debug.Log(&quot;Show2-&gt;a+b:&quot;+(a+b)); //unity中Debug.Log不和Console类一样可以使用&#123;0&#125;代替 &#125; private void Show3(string a) &#123; Debug.Log(&quot;show3-&gt;a:&quot;+a); &#125;&#125; 2.using System命名空间内置的Action委托。(效果和delegate一样，同时是不带返回值的委托) 12345678910111213141516171819202122232425262728293031323334353637383940using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class HelloWorld : MonoBehaviour&#123; /*使用Action就无需delegate定义(其实Action委托底层就是delegate定义) public delegate void ShowDelegate(); public delegate void ShowDelegate2(int a,int b); public delegate void ShowDelegate3&lt;T&gt; (T a); //泛型委托定义，前面加&lt;T&gt;，后面参数中才能使用T，T可以用任意类型代替 */ // Start is called before the first frame update void Start() &#123; Action action1 =Show1; //使用方法和delegate一样 action1.Invoke(); Action&lt;int, int&gt; action2 = Show2; //Action重载很多，可以自己探索使用 action2.Invoke(1,2); &#125; // Update is called once per frame void Update() &#123; &#125; void Show1() &#123; Debug.Log(&quot;Show1&quot;); &#125; void Show2(int a,int b) &#123; Debug.Log(&quot;Action:&quot; + (a + b)); &#125;&#125; 3.系统内置的Func委托。(带返回值的委托) 123456789101112131415161718192021222324252627282930313233343536using System;using System.Collections;using System.Collections.Generic;using UnityEngine;public class HelloWorld : MonoBehaviour&#123; void Start() &#123; //Func可以没有参数，但必须带返回值(泛型内定义中，最后参数的数据类型是函数的返回值类型) Func&lt;string&gt; func1 = Show1; string a = func1(); Debug.Log(a); //Func最后一个类型是返回值类型，前面的是参数类型，必须与函数中保持一致 Func&lt;int, string&gt; func2 = Show2; func2(3); &#125; void Update() &#123; &#125; string Show1() &#123; return &quot;Show1&quot;; &#125; //对应的就是Func&lt;int,string&gt;，最后一个参数就是返回值类型，前面的是参数类型 string Show2(int a) &#123; return a.ToString(); &#125;&#125; 4.匿名方法、多播委托。 （1）匿名方法与lamda表达式。12345678910111213141516void Start()&#123; //不用调入方法，直接写委托，就是匿名方法 Action action = delegate (string name) &#123; Debug.Log(&quot;匿名方法&quot;); &#125;; action.Invoke(&quot;张三&quot;); //lamda表达式缩写匿名方法 Action action1 = (name) =&gt; &#123; Debug.Log(&quot;lamda表达式&quot;); &#125;; action1.Invoke(&quot;张三&quot;);&#125; （2）多播委托。(使用+和-来添加和移除方法)123456789101112131415161718void Start()&#123; Action action = Show1; action += Show2; //加可以实现方法的添加 action -= Show2; //减实现方法的移除 if (action != null) //委托属于引用类型，引用类型的默认值是null，如果为空使用会报错空异常，所以在使用之前需要先判断委托(引用)对象是否为空 &#123; action(); //此时输出Show1 &#125;&#125;void Show1()&#123; Debug.Log(&quot;Show1&quot;);&#125;void Show2()&#123; Debug.Log(&quot;Show2&quot;);&#125; 5.委托的作用与意义。123456789void Start()&#123; //思考：下面两种输出方式有什么不同？ //答：显然，第一种方式里面i类似于指针，指向的是i的地址，只需要改变i中的内容，对应的输出值也会改变 int i = 6; Console.WriteLine(i); //而第二种，只能无脑的输出 Console.WriteLine(6);&#125; 同理，委托里装的是方法，我们可以通过修改委托里生成的委托实例，来调用不同的方法。 1234567891011121314151617181920212223242526void Start()&#123; //思考：下面两种输出方式有什么不同？ //答：显然，第一种方式里面i类似于指针，指向的是i的地址，只需要改变i中的内容，对应的输出值也会改变 int i = 6; Console.WriteLine(i); //而第二种，只能无脑的输出 Console.WriteLine(6); //同理，下面这两种方法的不同也一样 //我们可以通过改变委托生成的委托实例来调用不同的方法 Action action = Show1; action += Show2; action.Invoke(); //而第二种，只能无脑的调用 Show1();&#125;void Show1()&#123; Debug.Log(&quot;Show1&quot;);&#125;void Show2()&#123; Debug.Log(&quot;Show2&quot;);&#125; 二：事件。1.事件event的定义和调用。注：event事件，只允许作为类的成员变量(定义时不能在函数方法内部使用)，且仅在类的内部使用才可以，外部不得直接调用。 12345678910111213141516171819202122232425262728public class MyEventClass&#123; //定义：访问修饰符+event+委托名+要定义的事件名称 public event Action eventAction; //外部调用eventAction只能通过+=或-=，或者下面的方法间接调用 public Action defaultAction; public void Send() //通过类中方法，可以让外部间接调用event &#123; if(eventAction!= null) &#123; eventAction(); &#125; &#125;&#125;public class HelloWorld : MonoBehaviour&#123; void Start() &#123; MyEventClass myEventClass= new MyEventClass(); myEventClass.eventAction += Show1; //类中event对应的委托，只能通过+=来增加，不能赋值= myEventClass.defaultAction = Show2; //普通的Action委托，可以赋值=，也可以+= //myEventClass.eventAction(); //报错，因为event对应的，只能出现在+=或-=式子中 myEventClass.Send(); //但是可以通过调用类中的方法来间接调用event myEventClass.defaultAction(); &#125;&#125; 2.事件和委托的关系。123456789101112131415161718192021222324252627282930public class HelloWorld : MonoBehaviour&#123; //event事件声明时无需立刻注册一个方法 event Action action; void Start() &#123; //委托在声明时必须立刻为它注册一个方法，但有些时候并不是总想这样 Action action1 = Show1; action1 += Show2; action1.Invoke(); //而事件无需声明时，就要立刻注册一个方法，我们想要它添加方法时就添加 action +=Show1; action.Invoke(); &#125; void Update() &#123; &#125; void Show1() &#123; Debug.Log(&quot;Show1&quot;); &#125; void Show2() &#123; Debug.Log(&quot;Show2&quot;); &#125;&#125; 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"Unity笔记","slug":"unity笔记day1","date":"2023-02-19T15:08:52.000Z","updated":"2023-02-23T14:54:22.858Z","comments":true,"path":"2023/02/19/unity笔记day1/","link":"","permalink":"http://example.com/2023/02/19/unity%E7%AC%94%E8%AE%B0day1/","excerpt":"","text":"Unity笔记一：游戏场景。1.游戏场景。 2.场景漫游。(鼠标右键，中键和Alt三种) 二：Unity内置简易模型与材质。(在Hierarchy面板中右键添加选择3D Object添加) 1.网格过滤器Sphere(Mesh Filter)。注：网格过滤器说明这个物体用的网格，网格数据是什么，就决定了这个物体长什么样。 2.网格渲染器(Mesh Renderer)。注：Materials对应的就是材质，右边的数量就是该物体材质的数量，下面的具体元素就是所需的材质。 3.新建材质。 然后可以在右边Inspector面板中，修改对应的材质属性。 三：Scene界面游戏物体操作。1.工具栏。(实际上就是改变Transform组件中的值) （1）第一个中的Center和Pivot是关于中心点的切换。(如果有子物体就会出现区别)注：Center指的是整个图形的中心，如下图，会选择3个Cube的中心(unity会自动计算三个图形的中心点)；而如果选择Pivot，左侧选择图形，则中心点是被选中图形的中心。 （2）第二个中的Global和Local是关于以全局坐标还是自身坐标为中心。注：如果此时是Global全局坐标，那么物体如下图的三维坐标朝向就是和世界坐标对应平行；而如果是Local自身坐标，那么物体的三维坐标朝向只是与物体自身的方向，不与世界坐标平行。 （3）缩放工具。注：如果父类缩放，子类也会有影响，且在缩放时，我们可以直接拖拽下面的灰色中心点进行长宽高的等比例缩放。 2.变化约束和模型吸附。 （1）变化约束。(按住Ctrl键然后移动、旋转、缩放物体，就会像帧一样，用固定的速度进行操作，不会像原来一样的操作很滑溜)注：可以通过修改Snap的相关参数来约束每一阶段的变化。 Grid And Snap在Edit中已经找不到了，现在移动到了下面的Increment Snapping中。 （2）模型吸附(选中物体后，一直按住V，然后选中物体的边角点拖动贴合另一个模型的边角处即可)。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"}],"author":"JCM"},{"title":"c#笔记day11-多态","slug":"c-笔记day11","date":"2023-02-18T14:16:30.000Z","updated":"2023-02-19T15:32:19.501Z","comments":true,"path":"2023/02/18/c-笔记day11/","link":"","permalink":"http://example.com/2023/02/18/c-%E7%AC%94%E8%AE%B0day11/","excerpt":"","text":"c#笔记第十一天一：FileStream和StreamReader。(相比File类，这两种可以操作大文件)1.利用FileStream来读写文件。123456789101112131415161718192021222324252627static void Main(string[] args)&#123; //FileStream 操作字节的，可以操作图片等格式 ---------- //使用FileStream来读入数据 //创建FileStream对象 FileStream fsRead = new FileStream(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;,FileMode.OpenOrCreate,FileAccess.Read); byte[] buffer = new byte[1024*1024*5]; //5M大小的字节数组 //返回本次实际读取到的有效字节数 int r=fsRead.Read(buffer, 0, buffer.Length); //将字节数组中每一个元素按照指定地点编码格式解码成字符串 string s=Encoding.UTF8.GetString(buffer,0,r); //关闭流 fsRead.Close(); //GC如果回收不了，我们手动释放流所占用的资源 fsRead.Dispose(); Console.WriteLine(s); ---------- //使用FileStream来写入数据,using会自动帮助我们回收资源 using (FileStream fsWrite = new FileStream(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;, FileMode.OpenOrCreate, FileAccess.Write)) &#123; string str = &quot;看有无覆盖&quot;; byte[] buffer1=Encoding.UTF8.GetBytes(str); fsWrite.Write(buffer1, 0, buffer1.Length); &#125; Console.WriteLine(&quot;写入成功&quot;);&#125; 2.使用FileStream实现多媒体文件的复制。12345678910111213141516171819202122232425public static void CopyFile(string source,string target)&#123; //1.我们创建一个负责读取的流 using(FileStream fsRead=new FileStream(source, FileMode.Open, FileAccess.Read)) &#123; //2.创建一行负责写入的流 using(FileStream fsWrite = new FileStream(target, FileMode.OpenOrCreate, FileAccess.Write)) &#123; //每次读取字节最多为5M byte[] buffer = new byte[1024 * 1024 * 5]; //因为文件可能会比较大，所以读取可能要通过循环 while (true) &#123; //返回本次实际读取到的字节数 int r = fsRead.Read(buffer, 0, buffer.Length); //如果返回0，也就代表读取完了 if (r == 0) &#123; break; &#125; fsWrite.Write(buffer, 0, r); &#125; &#125; &#125;&#125; 3.StreamReader和StreamWriter。(只能操作文本)1234567891011121314151617static void Main(string[] args)&#123; //StreamReader读文件 using(StreamReader sr=new StreamReader(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;,Encoding.UTF8)) &#123; while(!sr.EndOfStream) //判断是否读到了文本结尾 &#123; Console.WriteLine(sr.ReadLine()); &#125; &#125; //StreamWriter写文件 using (StreamWriter sw = new StreamWriter(@&quot;C:\\Users\\Administrator\\Desktop\\code1.txt&quot;,true)) //后面参数true代表是追加内容 &#123; sw.WriteLine(&quot;666&quot;); &#125;&#125; 二：多态。(为了让一个对象表现出多种类型，可以减少代码和屏蔽各个子类对象的差异)1. 虚方法。Person父类：方法前添加virtual，允许子类重写方法 12345678910111213141516171819202122//父类public class Person&#123; public Person(string name) &#123; this.Name = name; &#125; //静态成员，都要使用类名调用 private string _name; public string Name &#123; //当你输出属性值的时候(取值)，会执行get方法 get &#123; return this._name; &#125; //当你给属性赋值的时候，首先会执行set方法 set &#123; this._name = value; &#125; &#125; //父类中使用关键字virtual成虚方法，故能在子类中重写 public virtual void SayHello() &#123; Console.WriteLine(&quot;我叫&#123;0&#125;&quot;, this.Name); &#125;&#125; Chinese子类：方法前添加override，代表要重写方法 123456789101112public class Chinese:Person&#123; public Chinese(string name):base(name) &#123; &#125; //父类的SayHello是虚方法，子类重写，要加override public override void SayHello() &#123; Console.WriteLine(&quot;我是中国人，我叫&#123;0&#125;&quot;,this.Name); &#125;&#125; Japanese子类：方法前添加override，代表要重写方法 123456789101112public class Japanese : Person&#123; public Japanese(string name) : base(name) &#123; &#125; //父类的SayHello是虚方法，子类重写，要加override public override void SayHello() &#123; Console.WriteLine(&quot;八嘎，我叫&#123;0&#125;&quot;,this.Name); &#125;&#125; Korea子类：方法前添加override，代表要重写方法 123456789101112public class Korea : Person&#123; public Korea(string name) : base(name) &#123; &#125; //父类的SayHello是虚方法，子类重写，要加override public override void SayHello() &#123; Console.WriteLine(&quot;我是棒子，叫&#123;0&#125;&quot;, this.Name); &#125;&#125; Main：实现多态的调用，分别输出对应对象的方法 12345678910111213static void Main(string[] args)&#123; //实现多态的3种手段:1.虚方法 2.抽象类 3.接口 Chinese cn1=new Chinese(&quot;张三&quot;); Japanese j1 = new Japanese(&quot;树下君&quot;); Korea k1 = new Korea(&quot;金秀贤&quot;); Person[] pers = &#123; cn1,j1,k1&#125;; //创建父类数组存储子类对象 for(int i=0;i&lt;pers.Length;i++) &#123; //注：如果此处不用多态知识点，调用的仅是父类的方法 pers[i].SayHello(); //虽调用的是父类Person的方法，但因为虚方法重写，所以对应输出的是pers[i]对象的方法 &#125;&#125; 2.抽象类。(不知道父类如何实现方法时，就可以使用抽象类) Animal父类：在类前面添加abstract成为抽象类，然后抽象方法前也要加abstract；但抽象方法不允许有方法体，故只能让子类来重写。 1234567891011121314//抽象类中可以包含非抽象成员，子类只需要重写抽象成员public abstract class Animal&#123; //在父类知晓如何实现方法时，就使用虚方法 //而不知道父类如何实现方法时，就可以使用抽象类，这样父类的方法就可以不用写方法体，让子类写 //抽象方法不允许有方法体，且抽象方法只能出现在抽象类中 public abstract void Bark(); public void Test() &#123; //有方法体，但是空实现 &#125;&#125; Dog子类(非抽象类)：重写抽象方法 1234567public class Dog:Animal&#123; public override void Bark() &#123; Console.WriteLine(&quot;狗狗旺旺的叫&quot;); &#125;&#125; Cat子类(非抽象类)：重写抽象方法 1234567public class Cat:Animal&#123; public override void Bark() &#123; Console.WriteLine(&quot;猫咪喵喵的叫&quot;); &#125;&#125; Main类：抽象类的调用，只能通过申明父类类型去指向子类的对象 123456789static void Main(string[] args)&#123; //实现多态的3种手段:1.虚方法 2.抽象类 3.接口 //Animal a=new Animal(); //抽象类不允许创建自己的对象 Animal a = new Dog(); a.Bark(); //调用子类的对象 Animal b = new Cat(); b.Bark(); &#125; 3.接口。(继承具有单根性，一个子类只能继承一个父类，但是接口不受数量限制)（1）接口的声明和调用。(命名通常是I…able)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Main类:接口不能实例化自身public class Program&#123; static void Main(string[] args) &#123; //接口不能实例化自身 IFlyable flyable= new Human(); flyable.Fly(); //输出人类在飞 IFlyable fl=new Bird(); fl.Fly(); //输出鸟儿在飞 &#125;&#125; ----------Human子类:public class Human : IFlyable&#123; public string Name &#123; get =&gt; throw new NotImplementedException(); set =&gt; throw new NotImplementedException(); &#125; public void Fly() &#123; Console.WriteLine(&quot;人类在飞&quot;); &#125; public string Test() &#123; throw new NotImplementedException(); &#125;&#125;----------Bird子类: public class Bird : IFlyable&#123; public string Name &#123; get =&gt; throw new NotImplementedException(); set =&gt; throw new NotImplementedException(); &#125; public void Fly() &#123; Console.WriteLine(&quot;鸟儿在飞&quot;); &#125; public string Test() &#123; throw new NotImplementedException(); &#125;&#125;--------IFlyable接口://interface是接口的标志，命名通常是I...ablepublic interface IFlyable&#123; //接口中的成员不允许添加访问修饰符，默认是public //接口中不允许写具有方法体的函数，而抽象类中可以写(抽象方法不能写方法体) void Fly(); string Test(); //接口中不能包含字段和构造函数(因为接口不能存数据)，但可以有自动属性 string Name &#123; get; set; &#125;&#125; （2）接口的特点。 （3）显示实现接口。(解决继承接口子类的方法重名问题)12345678910111213141516171819202122232425262728293031323334public class Program&#123; static void Main(string[] args) &#123; //显示实现接口就是为了解决方法的重名问题 IFlyable fl=new Bird(); fl.Fly(); //输出接口的鸟儿在飞 Bird bird=new Bird(); bird.Fly(); //输出鸟儿在飞 &#125;&#125; public class Bird : IFlyable&#123; public void Fly() &#123; Console.WriteLine(&quot;鸟儿在飞&quot;); &#125; //显示实现接口就是为了解决方法的重名问题 void IFlyable.Fly() &#123; Console.WriteLine(&quot;接口的鸟儿在飞&quot;); &#125;&#125;public interface IFlyable&#123; //接口中的成员不允许添加访问修饰符，默认是public //接口中不允许写具有方法体的函数，而抽象类中可以写(抽象方法不能写方法体) //接口中不能包含字段，但可以有自动属性 void Fly();&#125; 三：访问修饰符。 四：值传递和引用传递。(字符串的引用传递比较特殊，因为字符串具有不可变性) 12345678910111213141516171819202122232425static void Main(string[] args)&#123; //一般的引用类型 Person p1=new Person(&quot;张三&quot;); Person p2 = p1; p2.Name = &quot;李四&quot;; Console.WriteLine(p1.Name); //输出李四，因为引用类型指向同一个堆区域，更改堆内容，指向的全改变 //string引用类型 string s1 = &quot;张三&quot;; string s2 = s1; s2 = &quot;李四&quot;; Console.WriteLine(s1); //输出张三，字符串虽是引用类型，但因为字符串的不可变性，每次赋值都会在堆中开辟新的空间 Console.WriteLine(s2); //输出李四 //ref的作用 int a = 10; Test(ref a); //此次是实参，ref是将实参的空间引用栈中的形参空间，这样就相当于两块是同一个地址，这样一处改变值，另一处也会发生改变 Console.WriteLine(a); //输出20&#125;public static void Test(ref int n) //此次是形参&#123; n += 10;&#125; 五：序列化和反序列化。(为了传输数据) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Person类:前面必须加[Serializable]，说明是可以序列化的对象[Serializable]//父类public class Person&#123; public Person(string name) &#123; this.Name = name; &#125; //静态成员，都要使用类名调用 private string _name; public string Name &#123; //当你输出属性值的时候(取值)，会执行get方法 get &#123; return this._name; &#125; //当你给属性赋值的时候，首先会执行set方法 set &#123; this._name = value; &#125; &#125; ......&#125;---------------------------------Program类:static void Main(string[] args)&#123; //将对象序列化成二进制文件 Person p = new Person(&quot;张三&quot;); p.Age = 21; p.Gender = &#x27;男&#x27;; using(FileStream fsWrite=new FileStream(@&quot;C:\\Users\\Administrator\\Desktop\\test.txt&quot;, FileMode.OpenOrCreate, FileAccess.Write)) &#123; //开始序列化对象 BinaryFormatter bf = new BinaryFormatter(); bf.Serialize(fsWrite, p); &#125; //接收对方发送过来的二进制，反序列化成对象 Person p1; using(FileStream fsRead=new FileStream(@&quot;C:\\Users\\Administrator\\Desktop\\test.txt&quot;, FileMode.OpenOrCreate, FileAccess.Read)) &#123; BinaryFormatter formatter = new BinaryFormatter(); p1=(Person)formatter.Deserialize(fsRead); &#125; Console.WriteLine(p1.Name); //输出张三 Console.WriteLine(p1.Age); //输出21 Console.WriteLine(p1.Gender); //输出男&#125; 六：部分类。(类名不能有重复，但是如果前面都加partial成为部分类，则两个类相当于一个类，属性字段方法等共享) 七：密封类。(密封类不能被其他类继承，但可以继承其他类) 八：重写父类的ToString()方法。注：下面三个函数都是object类的虚方法，所以子类可以重写。 不是抽象类原因：1.ToString方法在未被重写下，object的任何子类都可以调用，说明该方法在父类中已经被定义过;2.抽象方法必须由子类重写，否则会报错，但是它的子类中不重写也不会报错。 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day10-Hashtable、List、字典集合","slug":"c-笔记day10","date":"2023-02-17T13:39:36.000Z","updated":"2023-02-23T08:32:00.063Z","comments":true,"path":"2023/02/17/c-笔记day10/","link":"","permalink":"http://example.com/2023/02/17/c-%E7%AC%94%E8%AE%B0day10/","excerpt":"","text":"c#笔记第十天一：Hashtable集合。1.var推断类型。（缺点：初始化时必须赋初值） 2.Hashtable的使用。12345678910111213141516171819202122232425static void Main(string[] args)&#123; //创建了一个键值对集合对象 Hashtable ht = new Hashtable(); ht.Add(1, &quot;张三&quot;); ht.Add(2, true); ht.Add(3, &#x27;男&#x27;); ht.Add(false, &quot;错误的&quot;); ht[4] = &quot;新来的&quot;; //这也是添加数据的方式 ht[1] = &quot;李四&quot;; //这种方式可以改变键1中的内容，而用Add添加重复的键会报错 if (!ht.ContainsKey(5)) //如果保护对应的键 &#123; ht.Add(5, &quot;6&quot;); ht.Remove(5); //以键的形式移除 ht[false] = &quot;正确的&quot;; //这种方式可以改变键false中的内容， &#125; //在键值对集合中，是根据键去找值的，使用foreach循环遍历键值对 foreach (var item in ht.Keys) &#123; //item是键(因为是ht.Keys)，而ht[item]就是值 Console.WriteLine(ht[item]); &#125;&#125; 二：简繁转换。1.一个键对应一个值，手动使用Hashtable键值对进行转换。 三：Path类和File类。1.Path类的方法。 2.File类的基本操作。1234567891011121314151617181920static void Main(string[] args)&#123; //创建一个文件 File.Create(@&quot;C:\\Users\\Public\\Desktop\\new.txt&quot;); Console.WriteLine(&quot;创建成功&quot;); //删除一个文件 File.Delete(@&quot;C:\\Users\\Public\\Desktop\\new.txt&quot;); Console.WriteLine(&quot;删除成功&quot;); //复制一个文件,Copy左边的参数是原文件，右边的参数路径是将要产生的新文件(必须原先是不存在的) File.Copy(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;, @&quot;C:\\Users\\Public\\Desktop\\new.txt&quot;); Console.WriteLine(&quot;复制成功&quot;); //移动一个文件，将文件从一个目录到另一个路径下，右边参数是移动后的路径，左边参数是原路径 File.Move(@&quot;A&quot;,@&quot;B&quot;); Console.WriteLine(&quot;移动文件成功&quot;); &#125; 3.File编码和文件。(File类只能用于小文件)（1）ReadAllBytes、ReadAllLines、ReadAllText读数据。1234567891011121314151617181920static void Main(string[] args)&#123; --------ReadAllBytes--------返回的是字节类型，因此支持图片等形式 //以字节流的形式从文件中读取字符，存储在字节数组中 byte[] buffer = File.ReadAllBytes(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;); //将字节数组中的每一个元素都按照我们指定的编码格式（可以点击文件另存为，看是什么编码方式）解码成字符串 //注：常见的编码格式有UTF-8、GB2312、GBK、ASCII、Unicode string s=Encoding.GetEncoding(&quot;UTF-8&quot;).GetString(buffer); Console.WriteLine(s); --------ReadAllLines--------不支持图片等形式，返回的是字符串数组类型 //以某种编码形式读取所有行 string[] contents=File.ReadAllLines(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;, Encoding.UTF8); foreach (string item in contents) &#123; Console.WriteLine(item); &#125; --------ReadAllText--------不支持图片等形式，返回的是字符串类型 //以某种编码形式读取所有文字 string s=File.ReadAllText(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;, Encoding.UTF8); Console.WriteLine(s);&#125; （2）WriteAllBytes、WriteAllLines、WriteAllText写数据。12345678910111213141516171819static void Main(string[] args)&#123; --------WriteAllBytes-------- //要在文件中输入的字符串 string str = &quot;123456789&quot;; //需要将字符串转换成字节数组 byte[]buffer=Encoding.GetEncoding(&quot;UTF-8&quot;).GetBytes(str); //没有这个文件就会自动创建一个；如果原来就有，则会覆盖其中内容 File.WriteAllBytes(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;, buffer); Console.WriteLine(&quot;写入成功&quot;); --------WriteAllLines-------- //以行形式写入字符数组到指定路径文件中 File.WriteAllLines(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;,new string[]&#123;&quot;123&quot;,&quot;456&quot; &#125;); Console.WriteLine(&quot;写入成功&quot;); --------WriteAllText-------- //写入字符串到指定路径文件中 File.WriteAllText(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;,&quot;张三666&quot;); Console.WriteLine(&quot;写入成功&quot;);&#125; （3）AppendAllText（Append也有三种）在文件中添加字符。123456static void Main(string[] args)&#123; //插入字符串到指定路径文件中 File.AppendAllText(@&quot;C:\\Users\\Administrator\\Desktop\\code.txt&quot;,&quot;张三666&quot;); Console.WriteLine(&quot;插入文字成功&quot;);&#125; 四：Directory类和DirectoryInfo类。1234567891011121314151617181920212223242526272829303132333435363738394041424344-----Directory类(静态类)-----void TestDirectory()&#123; //Directory是静态类，不可以创建实例，要直接调用 string path = @&quot;path1&quot;; //创建文件夹，返回的是DirectoryInfo类型 Directory.CreateDirectory(path); //判断某路径的文件夹是否存在，返回的是bool类型 Directory.Exists(path); //删除指定的文件夹，如果该文件夹下有子文件夹，需要在后面参数中添加true才能递归删除其和其子文件夹；否则就会报错 Directory.Delete(path, true); //移动文件夹到指定位置，把第一个参数路径下的文件移到第二个参数路径中 Directory.Move(path, @&quot;path2&quot;);&#125;-----DirectoryInfo类(非静态类)-----void TestDirectoryInfo()&#123; string path = @&quot;path1&quot;; //DirectoryInfo不是静态类，可以创建实例 DirectoryInfo directoryInfo = new DirectoryInfo(path); //创建文件夹 directoryInfo.Create(); //在刚刚的创建文件夹下创建子目录文件 directoryInfo.CreateSubdirectory(&quot;文件名&quot;); //删除指定的文件夹，如果该文件夹下有子文件夹，需要在参数中添加true才能递归删除其和其子文件夹 directoryInfo.Delete(true); //将文件移动到对应目录下 directoryInfo.MoveTo(@&quot;path2&quot;); //调用接口迭代器，输出子文件名 IEnumerable&lt;DirectoryInfo&gt; dir = directoryInfo.EnumerateDirectories(); foreach (var v in dir) &#123; Debug.Log(v.Name); &#125;&#125; 五：List泛型集合。1.List泛型集合的使用。(具体方法和ArrayList相似，不同点在于类型的确定，可以减少装箱、拆箱发生)12345678910111213141516171819static void Main(string[] args)&#123; //创建泛型集合对象 List&lt;int&gt; list= new List&lt;int&gt;(); list.Add(1); list.Add(2); list.Add(3); list.AddRange(new int[] &#123;4,5,6&#125;); //List泛型集合可以转换为数组 int[] nums=list.ToArray(); List&lt;int&gt; list2 = nums.ToList(); //输出List元素 for (int i = 0; i &lt; list.Count; i++) &#123; Console.WriteLine(list[i]); &#125;&#125; 2.装箱和拆箱。(类型转换都会影响效率)注：判断是否是拆装箱，先看两种类型有无继承关系。 1234567891011121314151617181920212223static void Main(string[] args)&#123; //值类型 int n = 10; //引用类型object object o = n; //将值类型赋值给引用类型，装箱 int nn = (int)o; //将引用类型强转为值类型，拆箱 //不断装箱，把int类型的i赋值装入到引用类型集合中 ArrayList list1= new ArrayList(); for(int i = 0; i &lt; 1000000; i++) &#123; //ArrayList的Add参数需要的是object类，所以这里把int类型赋值给object引用类型，发生了装箱 list1.Add(i); &#125; //没有发生装箱，运行速度快 List&lt;int&gt; list2 = new List&lt;int&gt;(); for (int i = 0; i &lt; 1000000; i++) &#123; list2.Add(i); &#125;&#125; 六：字典集合。123456789101112131415161718static void Main(string[] args)&#123; Dictionary&lt;int,string&gt; dic=new Dictionary&lt;int,string&gt;(); dic.Add(1, &quot;张三&quot;); dic[1] = &quot;李四&quot;; //修改键1中的值 //这是普通的输出遍历方式 foreach (var item in dic.Keys) &#123; Console.WriteLine(&quot;键是&#123;0&#125;，值是&#123;1&#125;&quot;, item, dic[item]); &#125; //这是字典另一种遍历方式 foreach (KeyValuePair&lt;int,string&gt; kv in dic) &#123; Console.WriteLine(&quot;键是&#123;0&#125;，值是&#123;1&#125;&quot;,kv.Key,kv.Value); &#125;&#125; 七：HashSet集合。注：HashSet集合是只能包含相同元素的集合，通常用来进行下面的取交并集操作使用，不过没有排序功能。 123456789101112131415161718192021222324252627void TestHashSet()&#123; //包含不重复项的无序列表 HashSet&lt;int&gt; hashset1=new HashSet&lt;int&gt;(); HashSet&lt;int&gt; hashset2 = new HashSet&lt;int&gt;(); hashset1.Add(1); hashset1.Add(2); hashset1.Add(2); //相同的元素添加约等于无用 Debug.Log(hashset1.Count); //输出2，因为里面有两个成员 hashset2.Add(2); hashset2.Add(3); //交集操作，将两种交集元素放在hashset1中 hashset1.IntersectWith(hashset2); //输出的是命名空间，那么就要遍历取值 //并集操作 hashset1.UnionWith(hashset2); //差集操作，是将h1中移除h1h2中共有元素。比如此处就是h1移除了共有的2，最后h1中只剩1 hashset1.ExceptWith(hashset2); //对称差集，就是将h1h2中移除共有元素。比如此次就是h1和h2中移除2，最后剩下的1和3放到h1中 hashset1.SymmetricExceptWith(hashset2); //遍历hashset1 foreach (var v in hashset1) &#123; Debug.Log(v); &#125;&#125; 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day9-里式转换","slug":"c-笔记day9","date":"2023-02-16T11:54:10.000Z","updated":"2023-02-18T14:59:01.434Z","comments":true,"path":"2023/02/16/c-笔记day9/","link":"","permalink":"http://example.com/2023/02/16/c-%E7%AC%94%E8%AE%B0day9/","excerpt":"","text":"c#笔记第九天一：里氏转换。1.子类可以赋值给父类：如果有一个地方需要一个父类作为参数，我们可以用子类代替。 12345678910static void Main(string[] args)&#123; //1.里氏转换 //（1）子类可以赋值给父类：如果有一个地方需要一个父类作为参数，我们可以用子类代替 Student s=new Student (&quot;张三&quot;,18,&#x27;男&#x27;,26); Person p = s; //等同于Person p=new Student (&quot;张三&quot;,18,&#x27;男&#x27;,26); //例如Join，后面填入的参数是object类数组(任何类的父类)，根据里氏转换，其中可填入任何子类的数组 string str = string.Join(&quot;|&quot;, new string[] &#123; &quot;1&quot; ,&quot;2&quot;&#125;); Console.WriteLine(str); //输出1|2&#125; 2.如果父类中装的是子类对象，那么可以将这个父类强转为子类对象。（1）is用法。 1234567891011121314static void Main(string[] args)&#123; Person p = new Student(&quot;张三&quot;, 18, &#x27;男&#x27;, 26); //is用法 if(p is Student) &#123; Student ss = (Student)p; //p中装的是子类对象Student，所以可以直接把p转换为子类对象 ss.Study(); //调用的就是Student类的Study方法 &#125; else &#123; Console.WriteLine(&quot;转换失败!&quot;); &#125;&#125; （2）as用法。 12345678static void Main(string[] args)&#123; //as用法 Person p = new Student(&quot;张三&quot;, 18, &#x27;男&#x27;, 26); Teacher t = p as Teacher; //此时t值就是Null，因为p此刻装的是Student，不能转为Teacher类 Student t1=p as Student; //此时t1值就不是Null，转换成功 t1.Study();&#125; 3.父类数组赋值、调用练习。（1）先对不同的类进行随机生成，然后父类数组装不同的子类对象。 （2）然后如果要调用每种类的方法，因为父类中装的是不同的子类对象，所以父类可以强制转换为对应的子类，然后调用。 二：protected访问修饰符。1.被protected修饰的内容，可以在类或子类中访问到。 2.Protected在类或子类外不能被访问。（故protected相比private，多了能在子类中访问的特性） 三：ArrayList。(给后面泛型集合做铺垫)1.ArrayList的使用和输出问题。123456789101112131415161718static void Main(string[] args)&#123; //创建了一个集合对象 ArrayList list= new ArrayList(); //集合：很多数据的一个集合 //数组：长度不可变、类型单一 //集合的好处：长度可以任意改变，类型随意 list.Add(1); list.Add(&#x27;6&#x27;); list.Add(new int[] &#123;2,3,4,5&#125;); ////这里后续输出是(对应类的命名空间)：System.Int32[] Person p = new Person(&quot;张三&quot;, 18, &#x27;男&#x27;); list.Add(p); //这里后续输出是(对应类的命名空间).Person list.Add(list); ////这里后续输出是(对应类的命名空间).ArrayList：System.Collections.ArrayList for (int i = 0; i &lt; list.Count; i++) &#123; Console.WriteLine(list[i]); &#125;&#125; 2.解决问题(使用list.AddRange)和其他集合类方法。1234567891011121314151617181920212223static void Main(string[] args)&#123; ArrayList list= new ArrayList(); //添加单个元素 list.Add(1); list.Add(true); //添加集合元素 list.AddRange(new int[] &#123; 2, 3, 4, 5 &#125;); //此次添加的就不是命名空间 list.AddRange(list); //再添加一遍自己 for (int i = 0; i &lt; list.Count; i++) &#123; Console.WriteLine(list[i]); &#125; list.Remove(1); //删除单个元素 list.RemoveAt(0); //删除下标索引元素 list.RemoveRange(0, 3); //根据下标删除一定范围的元素，如这里是删除从0索引开始的3个元素 //list.Sort(); //升序排序，注意里面的元素不同类型就会抛异常 list.Reverse(); //反转元素 list.Insert(0, &quot;插入&quot;); //在目标索引位置插入一个元素 list.InsertRange(0,new string[] &#123; &quot;张三&quot;, &quot;李四&quot; &#125;); //在目标索引位置插入集合 list.Contains(1); //判断是否包含某个指定元素，返回bool类型 list.Clear(); //清除所有元素&#125; 3.ArrayList长度问题。例如：count&#x3D;1，capacity&#x3D;4； count&#x3D;5，capacity&#x3D;8；(count每次超出capacity数量，capacity就会翻倍开辟) count&#x3D;9，capacity&#x3D;16 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day8-字符串和继承","slug":"c-笔记day8","date":"2023-02-15T12:02:27.000Z","updated":"2023-02-23T07:24:28.429Z","comments":true,"path":"2023/02/15/c-笔记day8/","link":"","permalink":"http://example.com/2023/02/15/c-%E7%AC%94%E8%AE%B0day8/","excerpt":"","text":"c#笔记第八天一：命名空间。1. 定义，namespace上方的引用。 2.不同项目之间引用。（1）右键依赖项，选择添加项目引用。 （2）选择将另一个项目的引用打上勾。 （3）然后在命名空间namespace上添加using+引用项目的namespace名称，就可以使用另一项目内的类和其他信息。 二：值类型和引用类型。 三：字符串。1.字符串的不可变性：当你给一个字符串重新赋值之后，老值并没有销毁，而是重新开辟一块空间存储新值。 2.字符串方法–&gt;上。 （1）ToCharArray()，将字符串转换为char数组；（2）new string(char[] chs)，将char数组转换为字符串。1234567891011121314static void Main(string[] args)&#123; //可以将string类型，看做是char类型的一个只读数组 string s = &quot;abcdefg&quot;; //如果想要改变字符串的第一个字符 //使用s[0]=&#x27;b&#x27;错误，因为s[0]是只读的，不可写 //正确方法：1.先将字符串转换为char类型的数组 char[] chs = s.ToCharArray(); chs[0] = &#x27;b&#x27;; //2.将字符数组转换为字符串 s=new string(chs); Console.WriteLine(s[0]); //输出b&#125; （3）StringBuilder和string。 补充：StringBuilder的Append和AppendFormat的使用方法。 12345678910111213141516static void Main(string[] args)&#123; StringBuilder sb = new StringBuilder(); string str = null; //创建一个计时器，用来记录程序运行的时间 Stopwatch sw = new Stopwatch(); sw.Start(); //开始计时 for (int i = 0; i &lt; 100000; i++) &#123; //str += i; //使用string类型运行，因为字符串会一直开辟新空间，速度慢 sb.Append(i); //使用StringBuilder运行，不会像string类型一直开新的空间，所以运行速度快 &#125; sw.Stop(); //停止计时 Console.WriteLine(sb.ToString()); //使用StringBuilder记得最后，要转为字符串 Console.WriteLine(sw.Elapsed); &#125; （4）Equals、Length、ToUpper、ToLower。 12345678910111213static void Main(string[] args)&#123; string a = &quot;c#&quot;; string b = &quot;C#&quot;; if(a.Equals(b,StringComparison.OrdinalIgnoreCase)) //比较两个字符串，且不区分大小写 &#123; Console.WriteLine(&quot;相同&quot;); &#125; else &#123; Console.WriteLine(&quot;不同&quot;); &#125;&#125; （5）Split分割字符串。 1234567891011121314151617static void Main(string[] args)&#123; string str = &quot;a b dfd _ + = ,,, fdf&quot;; //分割字符串Split char[] chs = &#123; &#x27; &#x27;, &#x27;_&#x27;, &#x27;+&#x27;, &#x27;=&#x27;, &#x27;,&#x27; &#125;; //以某个字符进行分割，多个不要的字符就建一个字符数组 //因为Split会将上面的分割字符变为&#x27;&#x27;(而不是删除)，为了删除，后面使用了StringSplitOptions.RemoveEmptyEntries来删除这些空字符 string[] s=str.Split(chs,StringSplitOptions.RemoveEmptyEntries); for (int i = 0; i &lt; s.Length; i++) &#123; Console.WriteLine(s[i]); //输出： //a--&gt;s[0] //b //dfd //fdf &#125;&#125; 3.字符串方法–&gt;下。 （1）Contains和Replace。1234567891011static void Main(string[] args)&#123; string str = &quot;洼牌游戏&quot;; //如果字符串中包含执行 if (str.Contains(&quot;洼牌&quot;)) &#123; //替换，然后接收 str=str.Replace(&quot;洼牌&quot;, &quot;**&quot;); &#125; Console.WriteLine(str); //输出**游戏&#125; （2）Substring，截取字符串。123456static void Main(string[] args)&#123; string str = &quot;洼牌游戏,真好玩! &quot;; str = str.Substring(1,3); //字符串默认是从0开始的，这里是取1-3位置的字符 Console.WriteLine(str); //输出牌游戏&#125; （3）StartsWith和EndsWith。1234567891011121314static void Main(string[] args)&#123; string str = &quot;洼牌游戏,真好玩!&quot;; //字符串以...开头 if (str.StartsWith(&quot;游戏&quot;)) &#123; Console.WriteLine(&quot;是的&quot;); &#125; //字符串以...结尾 if(str.EndsWith(&quot;好玩!&quot;)) &#123; Console.WriteLine(&quot;不是&quot;); &#125;&#125; （4）IndexOf和LastIndexOf。12345678910111213static void Main(string[] args)&#123; string str = &quot;玩洼牌游戏,真好玩!&quot;; //IndexOf是找从XX开始的第一个X字符的位置，此处是找从0位置开始第一个&#x27;玩&#x27;字符的位置 int index=str.IndexOf(&#x27;玩&#x27;,0); Console.WriteLine(index); //输出0 //LastIndexOf相反，是从字符串末尾回头寻找第一个X字符位置 int index2 = str.LastIndexOf(&#x27;玩&#x27;); Console.WriteLine(index2); //输出8 //配合Substring，使str变为从index2的位置到最后的字符串 str=str.Substring(index2); Console.WriteLine(str);&#125; （5）Trim、TrimStart、TrimEnd。123456789static void Main(string[] args)&#123; string str = &quot; ha hahah &quot;; //Trim去除从第一个字符前面和最后一个字符后面的全部空格 str= str.Trim(); //str=str.TrimStart(); 同理，去除的是第一个字符前面的全部空格 //str=str.TrimEnd(); 去除的是最后一个字符后面的全部空格 Console.WriteLine(str); //输出ha hahah&#125; （6）其余方法和总结：注：字符串的方法只是调用微软写好的方法，而对于底层的代码才是我们必须要掌握的，所以学习时，可以思考实现相应功能的代码是怎么写的。 四：继承。(解决冗余)1.定义和调用。 Person类（父类）： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person&#123; private string _name; public string Name &#123; get &#123; return _name; &#125; set &#123; _name = value; &#125; &#125; private int _age; public int Age &#123; get &#123; return _age; &#125; set &#123; if (value &lt; 0 || value &gt; 120) &#123; value = 0; &#125; _age = value; &#125; &#125; private char _gender; public char Gender &#123; get &#123; if (_gender != &#x27;男&#x27; &amp;&amp; _gender != &#x27;女&#x27;) &#123; _gender = &#x27;男&#x27;; &#125; return _gender; &#125; set &#123; _gender = value; &#125; &#125; public void CHLSS() &#123; Console.WriteLine(&quot;吃喝拉撒睡&quot;); &#125;&#125; Teacher类（子类）：可以调用Person类的public字段和方法，只需要在后面加上:Person即可 12345678910111213141516public class Teacher : Person //Person是父类，因此子类可以调用父类的方法、属性&#123; private double _salary; public double Salary &#123; get &#123; return _salary; &#125; set &#123; _salary = value; &#125; &#125; public void Teach() &#123; Console.WriteLine(&quot;老师会讲课&quot;); &#125;&#125; 2.继承特性：单根性和传递性（即爷爷和孙子之间也可以继承方法和属性）。 3.使用:base()继承父类的构造函数。 子类new对象时，会先调用父类的构造函数，而如果父类构造函数改变，则也需要重写子类的构造函数，否则就会报错。 Person类（父类）： 12345678910111213public class Person&#123; //父类重写了构造函数，那么无参的构造函数就消失了，子类如果调用就会出错 public Person(string name,int age,char gender) &#123; this.Name = name; this.Age = age; this.Gender = gender; &#125; ------- 父类中的其余内容 -------&#125; Driver类（子类）： 1234567891011121314151617181920public class Driver: Person //Person是父类，因此子类可以使用父类的代码&#123; //因为父类的无参构造函数消失，所以我们子类调用的父类无参构造函数消失，那么子类也要写构造函数，后面使用:base填入父类的构造函数中 public Driver(string name,int age,char gender,int driveTime) :base(name,age,gender) &#123; this.DriveTime= driveTime; //Driver类特有的 &#125; private int _driveTime; public int DriveTime &#123; get &#123; return _driveTime; &#125; set &#123; _driveTime = value; &#125; &#125; public void Drive() &#123; Console.WriteLine(&quot;司机会开车&quot;); &#125;&#125; 4.创建并打开项目的类图。（1）选择工具栏，打开VS安装器。 （2）单个组件中安装类设计器。 （3）安装完成后重启VS，然后打开视图中的类视图，右边就会出现对应的项目。 （4）右键你需要添加类图的项目，创建类图。 （5）然后在类视图中，把右边的项目拖过来即可。 5.c#中，所有的类都继承于object类。 6.new关键字隐藏父类成员。 Person类（父类）： 1234public void CHLSS() &#123; Console.WriteLine(&quot;吃喝拉撒睡&quot;);&#125; Driver类（子类）： 12345//子类中如果有和父类同名的方法，添加new在子类对方法中时，会优先使用子类方法，隐藏父类的方法public new void CHLSS() &#123; Console.WriteLine(&quot;666&quot;); //如果是Driver类对象调用CHLSS方法，输出的就是666，而不是父类的吃喝拉撒睡&#125; 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day7-面向对象和类","slug":"c-笔记day7","date":"2023-02-14T12:23:20.000Z","updated":"2023-02-19T07:52:36.393Z","comments":true,"path":"2023/02/14/c-笔记day7/","link":"","permalink":"http://example.com/2023/02/14/c-%E7%AC%94%E8%AE%B0day7/","excerpt":"","text":"C#笔记第七天一：类的基本语法。 1234567891011121314151617181920212223242526272829303132Program.cs：namespace c_sharp_project&#123; internal class Program &#123; static void Main(string[] args) &#123; //创建Person类的对象或实例化一个类的对象 Person person= new Person(); person._name = &quot;孙权&quot;; person._age = 23; person._gender = &#x27;男&#x27;; person.CHLSS(); &#125; &#125;&#125;Person.cs：namespace c_sharp_project&#123; public class Person &#123; public string _name; public int _age; public char _gender; public void CHLSS() &#123; Console.WriteLine(&quot;我叫&#123;0&#125;,我今年&#123;1&#125;岁了,我是&#123;2&#125;生,我可以吃喝拉撒睡!&quot;, this._name, this._age, this._gender) ; &#125; &#125;&#125; 二：属性，如果是只读，那么只有get()；同理，只写就只有set()。1.普通属性。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person&#123; private string _name; //字段存数据 public string Name //属性是public，为了保护private字段 &#123; //当你输出属性值的时候(取值)，会执行get方法 get &#123; return _name; &#125; //当你给属性赋值的时候，首先会执行set方法 set &#123; _name = value; &#125; &#125; private int _age; public int Age &#123; get &#123; return _age; &#125; set &#123; if(value &lt; 0 || value &gt; 150) &#123; value= 0; &#125; _age = value; &#125; &#125; private char _gender; public char Gender &#123; get &#123; if (_gender != &#x27;男&#x27; &amp;&amp; _gender != &#x27;女&#x27;) &#123; return _gender =&#x27;男&#x27;; &#125; return _gender; &#125; set &#123; _gender = value; &#125; &#125; public void CHLSS() &#123; Console.WriteLine(&quot;我叫&#123;0&#125;,我今年&#123;1&#125;岁了,我是&#123;2&#125;生,我可以吃喝拉撒睡!&quot;, this.Name, this.Age, this.Gender) ; //所以此处调用只能访问属性，不能访问私有字段 &#125;&#125; 2.自动属性。(效果和普通属性一样，但缺点就是set和get中不能限定关于字段的条件)123456789101112131415161718192021public class Person&#123; ----普通属性定义---- //静态成员，都要使用类名调用 private string _name; public string Name &#123; //当你输出属性值的时候(取值)，会执行get方法 get &#123; return this._name; &#125; //当你给属性赋值的时候，首先会执行set方法 set &#123; this._name = value; &#125; &#125; ----自动属性定义，效果和上面普通属性一样，系统会自动创建_name字段---- public string Name &#123; get; set; &#125; &#125; 三：静态和非静态的区别。1. 非静态类，既可以有实例成员，也可以有静态成员。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152namespace c_sharp_project&#123; public class Person &#123; //静态成员，都要使用类名调用 private static string _name; public static string Name &#123; //当你输出属性值的时候(取值)，会执行get方法 get &#123; return Person._name; &#125; //当你给属性赋值的时候，首先会执行set方法 set &#123; Person._name = value; &#125; &#125; private int _age; public int Age &#123; get &#123; return _age; &#125; set &#123; if(value &lt; 0 || value &gt; 150) &#123; value= 0; &#125; _age = value; &#125; &#125; private char _gender; public char Gender &#123; get &#123; if (_gender != &#x27;男&#x27; &amp;&amp; _gender != &#x27;女&#x27;) &#123; return _gender =&#x27;男&#x27;; &#125; return _gender; &#125; set &#123; _gender = value; &#125; &#125; //非静态函数，既可以访问静态成员，也可以访问实例成员 public void CHLSS() &#123; Console.WriteLine(&quot;我叫&#123;0&#125;,我今年&#123;1&#125;岁了,我是&#123;2&#125;生,我可以吃喝拉撒睡!&quot;, Person.Name, this.Age, this.Gender); &#125; //静态函数，只能访问静态成员 public static void CHLSS1() &#123; Console.WriteLine(&quot;我叫&#123;0&#125;是静态方法!&quot;,Person.Name); &#125; &#125;&#125; 2.静态类，里面只允许有静态成员，不允许出现实例成员；且调用时只能使用类名.静态成员名。如：经常使用的Console类就是静态类，里面的方法都是静态的。 3.静态类常当作“工具类”使用，即整个项目都要使用的类。 四：构造函数。1.构造函数的概念。 123456789101112131415161718192021222324252627282930313233343536373839404142Student.cs:namespace c_sharp_project&#123; public class Student &#123; //构造函数，创建对象时会调用，因此可以提前赋值且必须是public public Student(string name,int age,char gender,int chinese,int math,int english) &#123; this.Name= name; this.Age= age; this.Gender= gender; this.Chinese= chinese; this.English= english; this.Math= math; &#125; //构造函数可以有重载 public Student(string name)&#123; this.Name=name; &#125; &#125;&#125;Program.cs:namespace c_sharp_project&#123; internal class Program &#123; static void Main(string[] args) &#123; Student zsStudent = new Student(&quot;张三&quot;,18,&#x27;男&#x27;,100,100,100); /*用了构造函数后，下面这些就不用写了 zsStudent.Name = &quot;张三&quot;; zsStudent.Age = 18; zsStudent.Gender = &#x27;男&#x27;; zsStudent.Chinese = 100; zsStudent.Math= 100; zsStudent.English = 100; */ zsStudent.SayHello(); zsStudent.ShowScore(); &#125; &#125;&#125; 五：关键字。1.new关键字。 2.this关键字。 123456789101112131415161718192021222324252627public class Student&#123;----------------------Name等属性和其他字段的定义---------------------- public Student(string name,int age,char gender,int chinese,int math,int english) //构造函数，创建对象时会调用，所以可以提前赋值 &#123; this.Name= name; this.Age= age; this.Gender= gender; this.Chinese= chinese; this.English= english; this.Math= math; &#125; //通过:this()调用上面最全的构造函数填入 public Student(string name,int chinese,int math,int english):this(name,0,&#x27;c&#x27;,chinese,math,english) &#123; &#125; public void SayHello()&#123; string Name=&quot;张三&quot;; Console.WriteLine(&quot;我的名字是&#123;0&#125;&quot;,this.Name); //输出的名字是在构造函数中赋的值，加上this就代表当前类的对象 Console.WriteLine(&quot;我的名字是&#123;0&#125;&quot;,Name); //输出：我的名字是张三，这里没有加this的就是局部变量 &#125;&#125; 六：析构函数。12345678910public class Student&#123; //当程序结束时，析构函数才执行，作用是帮助我们释放资源 //GC Garbage Collection，这是.net自动帮助回收资源 //如果你想要资源马上被释放，就可以主动使用析构函数来释放资源；不使用，就会被GC来释放 ~Student() &#123; Console.WriteLine(&quot;我是析构函数&quot;); &#125;&#125; 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day6-飞行棋","slug":"c-笔记day6","date":"2023-02-13T10:24:07.000Z","updated":"2023-02-13T13:42:14.382Z","comments":true,"path":"2023/02/13/c-笔记day6/","link":"","permalink":"http://example.com/2023/02/13/c-%E7%AC%94%E8%AE%B0day6/","excerpt":"","text":"C#笔记第六天一：游戏头。 12345678910111213141516/// &lt;summary&gt;/// 游戏头/// &lt;/summary&gt;public static void GameShow()&#123; Console.ForegroundColor = ConsoleColor.Yellow; //调用Console类方法设置文字的前景色 Console.WriteLine(&quot;*************************&quot;); Console.ForegroundColor = ConsoleColor.Green; Console.WriteLine(&quot;*************************&quot;); Console.ForegroundColor = ConsoleColor.Cyan; Console.WriteLine(&quot;*******飞行棋小游戏*******&quot;); Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine(&quot;*************************&quot;); Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine(&quot;*************************&quot;);&#125; 二：初始化地图。123456789101112131415161718192021222324252627282930public static int[] Maps = new int[100]; //定义全局字段/// &lt;summary&gt;/// 初始化地图/// &lt;/summary&gt;public static void InitMap()&#123; int[] luckyturn = &#123; 6, 23, 40,55,69,83 &#125;; //幸运轮盘◎ for (int i = 0; i &lt; luckyturn.Length; i++) &#123; Maps[luckyturn[i]] = 1; //0是□，1是◎ &#125; int[] landMine = &#123; 5,13,17,33,38,50,64,80,94&#125;; //地雷☆ for (int i = 0; i &lt; landMine.Length; i++) &#123; Maps[landMine[i]] = 2; //2是☆ &#125; int[] pause = &#123; 9, 27, 60, 93 &#125;; //暂停▲ for (int i = 0; i &lt; pause.Length; i++) &#123; Maps[pause[i]] = 3; //3是▲ &#125; int[] timeTunnel = &#123; 20, 25, 45, 63, 72, 88, 90 &#125;; //时空隧道卐 for (int i = 0; i &lt; timeTunnel.Length; i++) &#123; Maps[timeTunnel[i]] = 4; //4是卐 &#125;&#125; 三：绘制地图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public static int[] Maps = new int[100]; //定义全局字段public static int[] PlayPos=new int[2]; //定义一个数组存储两个玩家的坐标.../// &lt;summary&gt;/// 绘制每行每列的图形/// &lt;/summary&gt;public static void DrawMap()&#123; //画第一横行0~29，记得最后要换行 for (int i = 0; i &lt; 30; i++) &#123; Console.Write(DrawStringMap(i)); &#125; Console.WriteLine();//换行 //画第一竖行30~34 for (int i = 30; i &lt; 35; i++) &#123; for (int j = 0; j &lt; 29; j++) &#123; Console.Write(&quot; &quot;); &#125; Console.Write(DrawStringMap(i)); Console.WriteLine();//换行 &#125; //画第二横行35~64，记得最后要换行 for (int i = 64; i &gt;= 35; i--) &#123; Console.Write(DrawStringMap(i)); &#125; Console.WriteLine();//换行 //画第二竖行65~69 for (int i = 65; i &lt;70; i++) &#123; Console.WriteLine(DrawStringMap(i)); &#125; //画第三横行35~64，记得最后要换行 for (int i = 70; i &lt;100 ; i++) &#123; Console.Write(DrawStringMap(i)); &#125; Console.WriteLine();//换行&#125;----------------------------------------/// &lt;summary&gt;/// 从地图中抽象出来的方法/// &lt;/summary&gt;/// &lt;param name=&quot;i&quot;&gt;位置&lt;/param&gt;/// &lt;returns&gt;string类型的图形&lt;/returns&gt;public static string DrawStringMap(int i)&#123; string str = &quot;&quot;; if (PlayPos[0] == PlayPos[1] &amp;&amp; PlayPos[0] == i) //如果玩家A跟玩家B的坐标相同，并且都在此地图上(防止踩到地雷退到-1位置导致无法绘制)，则画一个尖括号 &#123; str=&quot;&lt;&gt;&quot;; &#125; else if (PlayPos[0] == i) //如果A和B不在同一个位置，且在地图上，则绘制A &#123; str=&quot;Ａ&quot;; //全角的A，可以按shift+空格开启全角 &#125; else if (PlayPos[1] == i) //如果A和B不在同一个位置，且在地图上，则绘制B &#123; str=&quot;Ｂ&quot;; //全角的B，可以按shift+空格开启全角 &#125; else //绘制其余的图形 &#123; switch (Maps[i]) &#123; case 0: Console.ForegroundColor = ConsoleColor.Yellow; str= &quot;□&quot;; break; case 1: Console.ForegroundColor = ConsoleColor.Red; str= &quot;◎&quot;; break; case 2: Console.ForegroundColor = ConsoleColor.Green; str= &quot;☆&quot;; break; case 3: Console.ForegroundColor = ConsoleColor.Cyan; str= &quot;▲&quot;; break; case 4: Console.ForegroundColor = ConsoleColor.Blue; str= &quot;卐&quot;; break; &#125; &#125; return str;&#125; 四：输入玩家姓名。 12345678910111213141516171819202122232425262728293031public static string[] PlayerNames = new string[2]; //定义一个string数组存储两个玩家的姓名.../// &lt;summary&gt;/// 输入玩家姓名/// &lt;/summary&gt;public static void InputName()&#123; Console.WriteLine(&quot;请输入玩家A的姓名&quot;); PlayerNames[0] = Console.ReadLine(); while (PlayerNames[0] == &quot;&quot;) //A输入为空 &#123; Console.WriteLine(&quot;玩家A的姓名不能为空，请重新输入!&quot;); PlayerNames[0] = Console.ReadLine(); &#125; Console.WriteLine(&quot;请输入玩家B的姓名&quot;); PlayerNames[1] = Console.ReadLine(); while (PlayerNames[1] == &quot;&quot; || PlayerNames[1] == PlayerNames[0]) //B输入为空，或B输入内容和A一样 &#123; if(PlayerNames[1] == &quot;&quot;) &#123; Console.WriteLine(&quot;玩家B的姓名不能为空，请重新输入!&quot;); PlayerNames[1] = Console.ReadLine(); &#125; else &#123; Console.WriteLine(&quot;玩家B的姓名不能与A相同，请重新输入!&quot;); PlayerNames[1] = Console.ReadLine(); &#125; &#125;&#125; 五：清屏，Console.Clear()。123456789static void Main(string[] args)&#123; GameShow(); //游戏头 InputName(); //输入玩家姓名 Console.Clear(); //输完姓名，清屏 GameShow(); //重新绘制游戏头 InitMap(); //初始化地图 DrawMap(); //绘制&#125; 六：输出姓名等文本。 12345678910/// &lt;summary&gt;/// 清屏输入姓名后，输出文本和相关信息/// &lt;/summary&gt;public static void NameInformation()&#123; Console.ForegroundColor= ConsoleColor.Cyan; //改变文本颜色 Console.WriteLine(&quot;&#123;0&#125;的士兵用A表示&quot;, PlayerNames[0]); Console.WriteLine(&quot;&#123;0&#125;的士兵用B表示&quot;, PlayerNames[1]); Console.WriteLine(&quot;图例-&gt;(1)幸运转盘:◎ (2)地雷:☆ (3)暂停:▲ (4)时空隧道:卐 (5)玩家A:Ａ (6)玩家B:Ｂ (7)A与B重合:&lt;&gt;&quot;);&#125; 七：游戏玩家位置限定。12345678910111213141516171819202122/// &lt;summary&gt;/// 当玩家坐标发生改变的时候调用/// &lt;/summary&gt;public static void ChangePos()&#123; if (PlayPos[0] &lt; 0) //如果坐标发生改变后小于0，则赋0 &#123; PlayPos[0] = 0; &#125; if(PlayPos[0] &gt; 99) //如果坐标发生改变后大于99，则赋99 &#123; PlayPos[0] = 99; &#125; if(PlayPos[1] &lt; 0) &#123; PlayPos[1] = 0; &#125; if(PlayPos[1] &gt; 99) &#123; PlayPos[0] = 99; &#125;&#125; 八：游戏内的逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public static int[] Maps = new int[100]; //定义全局字段public static int[] PlayPos=new int[2]; //定义一个int数组存储两个玩家的坐标public static string[] PlayerNames = new string[2]; //定义一个string数组存储两个玩家的姓名public static bool[] Flags=new bool[2]; //两个玩家是否暂停的标记，默认是falsestatic void Main(string[] args)&#123; GameShow(); //游戏头 InputName(); //输入玩家姓名 Console.Clear(); //输完姓名，清屏 GameShow(); //重新绘制游戏头 NameInformation(); //输出姓名文本 InitMap(); //初始化地图 DrawMap(); //绘制 while (PlayPos[0] &lt; 99 &amp;&amp; PlayPos[1] &lt; 99) //当玩家A和玩家B没有一个人抵达终点的时候，两人一直进行游戏 &#123; if (Flags[0]==false) &#123; PlayGame(0); //A玩家操作 &#125; else //当前为暂停状态，要重置Flags，以便下回合继续玩 &#123; Flags[0] = false; &#125; if (PlayPos[0] &gt;= 99) &#123; Console.WriteLine(&quot;玩家&#123;0&#125;获胜！！！&quot;, PlayerNames[0]); break; &#125; if (Flags[1]==false) &#123; PlayGame(1); //B玩家操作 &#125; else //当前为暂停状态，要重置Flags，以便下回合继续玩 &#123; Flags[1] = false; &#125; if (PlayPos[1] &gt;= 99) &#123; Console.WriteLine(&quot;玩家&#123;0&#125;获胜！！！&quot;, PlayerNames[1]); break; &#125; &#125; Console.ReadKey();&#125;/// &lt;summary&gt;/// 进行游戏/// &lt;/summary&gt;/// &lt;param name=&quot;playerNumber&quot;&gt;玩游戏的人&lt;/param&gt;public static void PlayGame(int playerNumber)&#123; Random r= new Random(); //随机骰子数 int rNumber = r.Next(1, 7); //骰子是6面 Console.WriteLine(&quot;玩家&#123;0&#125;按任意键开始掷骰子&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); Console.WriteLine(&quot;玩家&#123;0&#125;掷出了&#123;1&#125;&quot;, PlayerNames[playerNumber],rNumber); PlayPos[playerNumber] += rNumber; ChangePos(); //每当坐标发生改变就调用 Console.ReadKey(true); Console.WriteLine(&quot;玩家&#123;0&#125;按任意键开始行动&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); Console.WriteLine(&quot;玩家&#123;0&#125;行动结束&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); if (PlayPos[playerNumber] == PlayPos[1-playerNumber]) //玩家A踩到了玩家B，玩家B退6格 &#123; Console.WriteLine(&quot;玩家&#123;0&#125;踩到了玩家&#123;1&#125;，玩家&#123;2&#125;退6格&quot;, PlayerNames[playerNumber], PlayerNames[1- playerNumber], PlayerNames[1- playerNumber]); PlayPos[1- playerNumber] -= 6; ChangePos(); //每当坐标发生改变就调用 Console.ReadKey(true); &#125; else //其余正常情况 &#123; switch (Maps[PlayPos[playerNumber]]) &#123; case 0: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了方块，安全。&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); break; case 1: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了幸运轮盘，请选择 1--交换位置 2--轰炸对方6格。&quot;, PlayerNames[playerNumber]); string input = Console.ReadLine(); while (true) &#123; if (input == &quot;1&quot;) &#123; Console.WriteLine(&quot;玩家&#123;0&#125;选择和玩家&#123;1&#125;交换位置&quot;, PlayerNames[playerNumber], PlayerNames[1- playerNumber]); int temp = PlayPos[playerNumber]; PlayPos[playerNumber] = PlayPos[1- playerNumber]; PlayPos[1- playerNumber] = temp; Console.WriteLine(&quot;交换成功！！！按任意键继续游戏！！！&quot;); Console.ReadKey(true); break; &#125; else if (input == &quot;2&quot;) &#123; Console.WriteLine(&quot;玩家&#123;0&#125;选择轰炸玩家&#123;1&#125;,玩家&#123;2&#125;退6格&quot;, PlayerNames[playerNumber], PlayerNames[1- playerNumber], PlayerNames[1 - playerNumber]); Console.ReadKey(true); PlayPos[1 - playerNumber] -= 6; ChangePos(); //每当坐标发生改变就调用 Console.WriteLine(&quot;玩家&#123;0&#125;退了6格&quot;, PlayerNames[1 - playerNumber]); Console.ReadKey(true); break; &#125; else &#123; Console.WriteLine(&quot;只能输入1或者2，请重新输入！&quot;); input = Console.ReadLine(); &#125; &#125; Console.ReadKey(true); break; case 2: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了地雷，退6格。&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); PlayPos[playerNumber] -= 6; ChangePos(); //每当坐标发生改变就调用 break; case 3: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了暂停，暂停一回合。&quot;, PlayerNames[playerNumber]); Flags[playerNumber] = true; //将其暂停属性置为true Console.ReadKey(true); break; case 4: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了时空隧道，前进10格。&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); PlayPos[playerNumber] += 10; ChangePos(); //每当坐标发生改变就调用 break; &#125; &#125; Console.Clear(); //每一轮结束都要清屏，重新绘制 NameInformation(); DrawMap();&#125; 九：源码。地址:https://github.com/jcm111859242/C--Flying-chess-games。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371namespace c_sharp_learning_first_day&#123; internal class Program &#123; public static int[] Maps = new int[100]; //定义全局字段 public static int[] PlayPos=new int[2]; //定义一个int数组存储两个玩家的坐标 public static string[] PlayerNames = new string[2]; //定义一个string数组存储两个玩家的姓名 public static bool[] Flags=new bool[2]; //两个玩家是否暂停的标记，默认是false static void Main(string[] args) &#123; GameShow(); //游戏头 InputName(); //输入玩家姓名 Console.Clear(); //输完姓名，清屏 GameShow(); //重新绘制游戏头 NameInformation(); //输出姓名文本 InitMap(); //初始化地图 DrawMap(); //绘制 while (PlayPos[0] &lt; 99 &amp;&amp; PlayPos[1] &lt; 99) //当玩家A和玩家B没有一个人抵达终点的时候，两人一直进行游戏 &#123; if (Flags[0]==false) &#123; PlayGame(0); //A玩家操作 &#125; else //当前为暂停状态，要重置Flags，以便下回合继续玩 &#123; Flags[0] = false; &#125; if (PlayPos[0] &gt;= 99) &#123; Console.WriteLine(&quot;玩家&#123;0&#125;获胜！！！&quot;, PlayerNames[0]); break; &#125; if (Flags[1]==false) &#123; PlayGame(1); //B玩家操作 &#125; else //当前为暂停状态，要重置Flags，以便下回合继续玩 &#123; Flags[1] = false; &#125; if (PlayPos[1] &gt;= 99) &#123; Console.WriteLine(&quot;玩家&#123;0&#125;获胜！！！&quot;, PlayerNames[1]); break; &#125; &#125; Console.ReadKey(); &#125; #region GameShow() /// &lt;summary&gt; /// 游戏头 /// &lt;/summary&gt; public static void GameShow() &#123; Console.ForegroundColor = ConsoleColor.Yellow; //调用Console类方法设置文字的前景色 Console.WriteLine(&quot;*************************&quot;); Console.ForegroundColor = ConsoleColor.Green; Console.WriteLine(&quot;*************************&quot;); Console.ForegroundColor = ConsoleColor.Cyan; Console.WriteLine(&quot;*******飞行棋小游戏*******&quot;); Console.ForegroundColor = ConsoleColor.Blue; Console.WriteLine(&quot;*************************&quot;); Console.ForegroundColor = ConsoleColor.Red; Console.WriteLine(&quot;*************************&quot;); &#125; #endregion #region InputName() /// &lt;summary&gt; /// 输入玩家姓名 /// &lt;/summary&gt; public static void InputName() &#123; Console.ForegroundColor= ConsoleColor.White; Console.WriteLine(&quot;请输入玩家A的姓名:&quot;); PlayerNames[0] = Console.ReadLine(); while (PlayerNames[0] == &quot;&quot;) //A输入为空 &#123; Console.WriteLine(&quot;玩家A的姓名不能为空，请重新输入!&quot;); PlayerNames[0] = Console.ReadLine(); &#125; Console.WriteLine(&quot;请输入玩家B的姓名:&quot;); PlayerNames[1] = Console.ReadLine(); while (PlayerNames[1] == &quot;&quot; || PlayerNames[1] == PlayerNames[0]) //B输入为空，或B输入内容和A一样 &#123; if (PlayerNames[1] == &quot;&quot;) &#123; Console.WriteLine(&quot;玩家B的姓名不能为空，请重新输入!&quot;); PlayerNames[1] = Console.ReadLine(); &#125; else &#123; Console.WriteLine(&quot;玩家B的姓名不能与A相同，请重新输入!&quot;); PlayerNames[1] = Console.ReadLine(); &#125; &#125; &#125; #endregion #region NameInformation() /// &lt;summary&gt; /// 清屏输入姓名后，输出文本 /// &lt;/summary&gt; public static void NameInformation() &#123; Console.ForegroundColor= ConsoleColor.Cyan; //改变文本颜色 Console.WriteLine(&quot;&#123;0&#125;的士兵用A表示&quot;, PlayerNames[0]); Console.WriteLine(&quot;&#123;0&#125;的士兵用B表示&quot;, PlayerNames[1]); Console.WriteLine(&quot;图例-&gt;(1)幸运转盘:◎ (2)地雷:☆ (3)暂停:▲ (4)时空隧道:卐 (5)玩家A:Ａ (6)玩家B:Ｂ (7)A与B重合:&lt;&gt;&quot;); &#125; #endregion #region InitMap() /// &lt;summary&gt; /// 初始化地图 /// &lt;/summary&gt; public static void InitMap() &#123; int[] luckyturn = &#123; 6, 23, 40,55,69,83 &#125;; //幸运轮盘◎ for (int i = 0; i &lt; luckyturn.Length; i++) &#123; Maps[luckyturn[i]] = 1; //0是□ &#125; int[] landMine = &#123; 5,13,17,33,38,50,64,80,94&#125;; //地雷☆ for (int i = 0; i &lt; landMine.Length; i++) &#123; Maps[landMine[i]] = 2; &#125; int[] pause = &#123; 9, 27, 60, 93 &#125;; //暂停▲ for (int i = 0; i &lt; pause.Length; i++) &#123; Maps[pause[i]] = 3; &#125; int[] timeTunnel = &#123; 20, 25, 45, 63, 72, 88, 90 &#125;; //时空隧道卐 for (int i = 0; i &lt; timeTunnel.Length; i++) &#123; Maps[timeTunnel[i]] = 4; &#125; &#125; #endregion #region DrawMap() /// &lt;summary&gt; /// 绘制每行每列的图形 /// &lt;/summary&gt; public static void DrawMap() &#123; //画第一横行0~29，记得最后要换行 for (int i = 0; i &lt; 30; i++) &#123; if(DrawStringMap(i)==&quot;Ａ&quot;|| DrawStringMap(i) == &quot;Ｂ&quot;) &#123; Console.ForegroundColor= ConsoleColor.White; &#125; Console.Write(DrawStringMap(i)); &#125; Console.WriteLine();//换行 //画第一竖行30~34 for (int i = 30; i &lt; 35; i++) &#123; for (int j = 0; j &lt; 29; j++) &#123; Console.Write(&quot; &quot;); &#125; if (DrawStringMap(i) == &quot;Ａ&quot; || DrawStringMap(i) == &quot;Ｂ&quot;) &#123; Console.ForegroundColor = ConsoleColor.White; &#125; Console.Write(DrawStringMap(i)); Console.WriteLine();//换行 &#125; //画第二横行35~64，记得最后要换行 for (int i = 64; i &gt;= 35; i--) &#123; if (DrawStringMap(i) == &quot;Ａ&quot; || DrawStringMap(i) == &quot;Ｂ&quot;) &#123; Console.ForegroundColor = ConsoleColor.White; &#125; Console.Write(DrawStringMap(i)); &#125; Console.WriteLine();//换行 //画第二竖行65~69 for (int i = 65; i &lt;70; i++) &#123; if (DrawStringMap(i) == &quot;Ａ&quot; || DrawStringMap(i) == &quot;Ｂ&quot;) &#123; Console.ForegroundColor = ConsoleColor.White; &#125; Console.WriteLine(DrawStringMap(i)); &#125; //画第三横行35~64，记得最后要换行 for (int i = 70; i &lt;100 ; i++) &#123; if (DrawStringMap(i) == &quot;Ａ&quot; || DrawStringMap(i) == &quot;Ｂ&quot;) &#123; Console.ForegroundColor = ConsoleColor.White; &#125; Console.Write(DrawStringMap(i)); &#125; Console.WriteLine();//换行 &#125; #endregion #region DrawStringMap(int i) /// &lt;summary&gt; /// 从地图中抽象出来的方法 /// &lt;/summary&gt; /// &lt;param name=&quot;i&quot;&gt;位置&lt;/param&gt; /// &lt;returns&gt;string类型的图形&lt;/returns&gt; public static string DrawStringMap(int i) &#123; string str = &quot;&quot;; if (PlayPos[0] == PlayPos[1] &amp;&amp; PlayPos[0] == i) //如果玩家A跟玩家B的坐标相同，并且都在此地图上(防止踩到地雷退到-1位置导致无法绘制)，则画一个尖括号 &#123; str=&quot;&lt;&gt;&quot;; &#125; else if (PlayPos[0] == i) //如果A和B不在同一个位置，且在地图上，则绘制A &#123; str=&quot;Ａ&quot;; //全角的A，可以按shift+空格开启全角 &#125; else if (PlayPos[1] == i) //如果A和B不在同一个位置，且在地图上，则绘制B &#123; str=&quot;Ｂ&quot;; //全角的B，可以按shift+空格开启全角 &#125; else &#123; switch (Maps[i]) &#123; case 0: Console.ForegroundColor = ConsoleColor.Magenta; str= &quot;□&quot;; break; case 1: Console.ForegroundColor = ConsoleColor.Red; str= &quot;◎&quot;; break; case 2: Console.ForegroundColor = ConsoleColor.Green; str= &quot;☆&quot;; break; case 3: Console.ForegroundColor = ConsoleColor.Cyan; str= &quot;▲&quot;; break; case 4: Console.ForegroundColor = ConsoleColor.Blue; str= &quot;卐&quot;; break; &#125; &#125; return str; &#125; #endregion #region PlayGame(int playerNumber) /// &lt;summary&gt; /// 进行游戏 /// &lt;/summary&gt; /// &lt;param name=&quot;playerNumber&quot;&gt;玩游戏的人&lt;/param&gt; public static void PlayGame(int playerNumber) &#123; Random r= new Random(); //随机骰子数 int rNumber = r.Next(1, 7); //骰子是6面 Console.ForegroundColor= ConsoleColor.White; Console.WriteLine(&quot;玩家&#123;0&#125;按任意键开始掷骰子&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); Console.WriteLine(&quot;玩家&#123;0&#125;掷出了&#123;1&#125;&quot;, PlayerNames[playerNumber],rNumber); PlayPos[playerNumber] += rNumber; ChangePos(); //每当坐标发生改变就调用 Console.ReadKey(true); Console.WriteLine(&quot;玩家&#123;0&#125;按任意键开始行动&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); Console.WriteLine(&quot;玩家&#123;0&#125;行动结束&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); if (PlayPos[playerNumber] == PlayPos[1-playerNumber]) //玩家A踩到了玩家B，玩家B退6格 &#123; Console.WriteLine(&quot;玩家&#123;0&#125;踩到了玩家&#123;1&#125;，玩家&#123;2&#125;退6格&quot;, PlayerNames[playerNumber], PlayerNames[1- playerNumber], PlayerNames[1- playerNumber]); PlayPos[1- playerNumber] -= 6; ChangePos(); //每当坐标发生改变就调用 Console.ReadKey(true); &#125; else //其余正常情况 &#123; switch (Maps[PlayPos[playerNumber]]) &#123; case 0: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了方块，安全。&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); break; case 1: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了幸运轮盘，请选择 1--交换位置 2--轰炸对方6格。&quot;, PlayerNames[playerNumber]); string input = Console.ReadLine(); while (true) &#123; if (input == &quot;1&quot;) &#123; Console.WriteLine(&quot;玩家&#123;0&#125;选择和玩家&#123;1&#125;交换位置&quot;, PlayerNames[playerNumber], PlayerNames[1- playerNumber]); int temp = PlayPos[playerNumber]; PlayPos[playerNumber] = PlayPos[1- playerNumber]; PlayPos[1- playerNumber] = temp; Console.WriteLine(&quot;交换成功！！！按任意键继续游戏！！！&quot;); Console.ReadKey(true); break; &#125; else if (input == &quot;2&quot;) &#123; Console.WriteLine(&quot;玩家&#123;0&#125;选择轰炸玩家&#123;1&#125;,玩家&#123;2&#125;退6格&quot;, PlayerNames[playerNumber], PlayerNames[1- playerNumber], PlayerNames[1 - playerNumber]); Console.ReadKey(true); PlayPos[1 - playerNumber] -= 6; ChangePos(); //每当坐标发生改变就调用 Console.WriteLine(&quot;玩家&#123;0&#125;退了6格&quot;, PlayerNames[1 - playerNumber]); Console.ReadKey(true); break; &#125; else &#123; Console.WriteLine(&quot;只能输入1或者2，请重新输入！&quot;); input = Console.ReadLine(); &#125; &#125; break; case 2: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了地雷，退6格。&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); PlayPos[playerNumber] -= 6; ChangePos(); //每当坐标发生改变就调用 break; case 3: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了暂停，暂停一回合。&quot;, PlayerNames[playerNumber]); Flags[playerNumber] = true; //将其暂停属性置为true Console.ReadKey(true); break; case 4: Console.WriteLine(&quot;玩家&#123;0&#125;踩到了时空隧道，前进10格。&quot;, PlayerNames[playerNumber]); Console.ReadKey(true); PlayPos[playerNumber] += 10; ChangePos(); //每当坐标发生改变就调用 break; &#125; &#125; Console.Clear(); //每一轮结束都要清屏，重新绘制 NameInformation(); DrawMap(); &#125; #endregion #region ChangePos() /// &lt;summary&gt; /// 当玩家坐标发生改变的时候调用 /// &lt;/summary&gt; public static void ChangePos() &#123; if (PlayPos[0] &lt; 0) //如果坐标发生改变后小于0，则赋0 &#123; PlayPos[0] = 0; &#125; if(PlayPos[0] &gt; 99) //如果坐标发生改变后大于99，则赋99 &#123; PlayPos[0] = 99; &#125; if(PlayPos[1] &lt; 0) &#123; PlayPos[1] = 0; &#125; if(PlayPos[1] &gt; 99) &#123; PlayPos[0] = 99; &#125; &#125; #endregion &#125;&#125; 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day5-方法","slug":"c-笔记day5","date":"2023-02-12T11:44:56.000Z","updated":"2023-02-13T09:44:25.910Z","comments":true,"path":"2023/02/12/c-笔记day5/","link":"","permalink":"http://example.com/2023/02/12/c-%E7%AC%94%E8%AE%B0day5/","excerpt":"","text":"c#笔记day5一：方法。1.方法的定义和使用。 123456789101112131415161718static void Main(string[] args)&#123; int a=Program.GetMax(int.Parse(Console.ReadLine()), int.Parse(Console.ReadLine())); //静态的方法使用类名.方法名调用 Console.WriteLine(a); Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中&#125;/// &lt;summary&gt;/// 计算两个整数之间的最大值并且将最大值返回/// &lt;/summary&gt;/// &lt;param name=&quot;n1&quot;&gt;第一个整数&lt;/param&gt;/// &lt;param name=&quot;n2&quot;&gt;第二个整数&lt;/param&gt;/// &lt;returns&gt;两种整数的最大值&lt;/returns&gt;public static int GetMax(int n1,int n2) //静态方法&#123; return n1&gt;n2 ? n1 : n2;&#125; 2.方法或参数的调用：传递参数或定义静态字段，第一个知识点是调用方法修改返回值，第二个知识点是全局变量定义在类中。 12345678910111213141516171819202122internal class Program&#123; public static int _b = 10; //类中的全局变量，作用域在整个类中 static void Main(string[] args) &#123; int a = 3; Console.WriteLine(Test1(a)); Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中 &#125; /// &lt;summary&gt; /// 将传入的变量值加6返回 /// &lt;/summary&gt; /// &lt;param name=&quot;a&quot;&gt;需要修改的变量&lt;/param&gt; /// &lt;returns&gt;加6过后的值&lt;/returns&gt; public static int Test1(int a) &#123; a+=6; return a; &#125; &#125; 二：out、ref、params参数。1.out参数。 123456789101112131415161718192021222324252627282930313233343536373839404142static void Main(string[] args)&#123; int[] nums = new int[9] &#123; 1,2,3,4,5,6,7,8,9&#125;; int max; int min; int sum; double avg; Test3(nums, out max, out min, out sum, out avg); //out可以让变量从方法中的值返回 Console.WriteLine(max); Console.WriteLine(min); Console.WriteLine(sum); Console.WriteLine(avg); Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中&#125;/// &lt;summary&gt;/// 计算一个整数数组的最大值、最小值、平均值、总和/// &lt;/summary&gt;/// &lt;param name=&quot;nums&quot;&gt;整数数组&lt;/param&gt;/// &lt;param name=&quot;max&quot;&gt;最大值&lt;/param&gt;/// &lt;param name=&quot;min&quot;&gt;最小值&lt;/param&gt;/// &lt;param name=&quot;sum&quot;&gt;总和&lt;/param&gt;/// &lt;param name=&quot;avg&quot;&gt;平均值&lt;/param&gt;public static void Test3(int[] nums,out int max,out int min,out int sum,out double avg)&#123; max = nums[0]; min = nums[0]; sum = 0; for (int i = 0; i &lt; nums.Length; i++) &#123; if (nums[i] &gt; max) &#123; max = nums[i]; &#125; if (nums[i] &lt; min) &#123; min = nums[i]; &#125; sum += nums[i]; &#125; avg = sum / nums.Length;&#125; 2.ref参数。 12345678910111213141516static void Main(string[] args)&#123; double salary = 5000; JiangJin(ref salary); //ref的变量值可以随着方法中值的改变而改变 Console.WriteLine(salary); //输出5500 Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中&#125;/// &lt;summary&gt;/// 让double类型变量值增加500/// &lt;/summary&gt;/// &lt;param name=&quot;s&quot;&gt;传入原变量&lt;/param&gt;public static void JiangJin(ref double s)&#123; s += 500;&#125; 3.params可变参数，这一项里面既可以填一个个对应类型的变量，也可以直接填入对应类型的数组。注：params参数数组必须是形参列表中的最后一个参数。 123456789101112131415static void Main(string[] args)&#123; Test(&quot;张三&quot;, 99, 88, 77); //params是可变参数，此次后续的99，88，77(如果还有添加也一样)放在params对应的数组中 Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中&#125;public static void Test(string name,params int[] score)&#123; int sum = 0; for(int i=0;i&lt;score.Length;i++) &#123; sum += score[i]; &#125; Console.WriteLine(&quot;&#123;0&#125;这次考试的总成绩是&#123;1&#125;&quot;, name, sum); &#125; 三：方法重载,先看方法名称，名称相同，再看参数类型和个数。 123456789101112131415161718192021222324252627282930313233namespace c_sharp_learning_first_day&#123; internal class Program &#123; static void Main(string[] args) &#123; Console.WriteLine(M(1.2,3)); //本次调用的是double返回值的M方法 Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中 &#125; public static void M(int n1,int n2) &#123; int result = n1 + n2; &#125; public static double M(double d1,double d2) &#123; return d1 + d2; &#125; public static void M(int n1,int n2,int n3) &#123; int result = n1 + n2+n3; &#125; public static string M(string s1,string s2) &#123; return s1 + s2; &#125; &#125;&#125; 四：方法递归，方法自己调用自己。1234567891011121314151617181920212223242526namespace c_sharp_learning_first_day&#123; internal class Program &#123; public static int i = 0; //定义全局字段用来后续递归的退出 static void Main(string[] args) &#123; TellStory(); Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中 &#125; public static void TellStory() &#123; Console.WriteLine(66); i++; if (i &gt;= 10) //设置方法递归退出条件 &#123; return; //退出方法 &#125; TellStory(); &#125; &#125;&#125; 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day4-枚举和结构","slug":"c-笔记day4","date":"2023-02-11T12:04:17.000Z","updated":"2023-02-13T09:44:32.486Z","comments":true,"path":"2023/02/11/c-笔记day4/","link":"","permalink":"http://example.com/2023/02/11/c-%E7%AC%94%E8%AE%B0day4/","excerpt":"","text":"c#笔记day4一：三元表达式。（注意整个三元表达式的结果类型和表达式2、3的结果类型一致） 二：产生随机数。（先new创建一个对象，然后调用Random类的next方法）123Random r= new Random();int rNumber=r.Next(1,10); //产生范围是左闭右开的区间，故此次范围为1~9，Console.WriteLine(rNumber); //随机输出1~9内的数 三：常量，只能赋初值，后续就不能再被赋值。 1234int number = 10;number = 20; //体现了变量可以被重新赋值const int numberTwo = 30; //常量，只能赋初值，不能够被重新赋值//numberTwo=90; //会报错，因为numberTwo是常量 四：枚举。（重要，unity使用多）1.概念和使用。 1234567891011121314151617namespace c_sharp_learning_first_day2&#123; public enum Gender //多写在命名空间下面，这样一个项目下的不同类中都能使用 &#123; 男, 女 &#125; internal class Program &#123; static void Main(string[] args) &#123; Gender gender = Gender.男; //调用 Console.WriteLine(gender); Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中 &#125; &#125;&#125; 2.enum中的值转int类型，默认在没赋值情况从0开始，后续递增+1。12345678910111213141516171819202122232425namespace c_sharp_learning_first_day2&#123; public enum QQState //多写在命名空间下面，这样一个项目下的不同类都能使用 &#123; OnLine=2, //默认未赋值为0，但此次赋值为2 OffLine, Leave=5, Busy, QMe, &#125; internal class Program &#123; static void Main(string[] args) &#123; QQState qqState = QQState.OnLine; //调用赋值 Console.WriteLine((int)qqState); //输出2 Console.WriteLine((int)QQState.OffLine); //输出3=2+1 Console.WriteLine((int)QQState.Leave); //输出5 Console.WriteLine((int)QQState.Busy); //输出6=5+1 Console.WriteLine((int)QQState.QMe); //输出7=5+2 Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中 &#125; &#125;&#125; 3.int转枚举同理，但如果int值超过枚举的数量，那么仍然输出int值。12345678910111213141516171819202122232425namespace c_sharp_learning_first_day2&#123; public enum QQState //多写在命名空间下面，这样一个项目下的不同类都能使用 &#123; OnLine, OffLine, Leave, Busy, QMe, &#125; internal class Program &#123; static void Main(string[] args) &#123; int a = 3; int b = 8; QQState qqState1 = (QQState)a; //将int类型转为QQState类型 QQState qqState2 = (QQState)b; //将int类型转为QQState类型 Console.WriteLine(qqState1); //输出Busy Console.WriteLine(qqState2); //输出8 Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中 &#125; &#125;&#125; 4.任何类型都能够调用.ToString()转换为字符串类型。123int n1 = 10;string s=n1.ToString(); //所有的类型都能够调用ToString转换为字符串类型Console.WriteLine(s); //输出字符串类型10 5.字符串类型转enum枚举类型。123string s = &quot;0&quot;; //如果转换的字符串内容是数字，就算枚举中没有，也不会抛异常；如果转换的字符串是文本，若枚举中没有，则会抛异常QQState state=(QQState)Enum.Parse(typeof(QQState), s); //Enum.Parse先获取QQState的类型，然后转为字符串类型，最后前面还要申明要转的是QQState类型Console.WriteLine(state); //输出OnLine 五：结构体struct。 1234567891011121314151617public struct Person&#123; public string _name; //字段 public int _age; public char _gender;&#125;internal class Program&#123; static void Main(string[] args) &#123; Person zsPerson; //定义变量方法和int、double等一样 zsPerson._name = &quot;张三&quot;; zsPerson._age = 21; zsPerson._gender = &#x27;男&#x27;; Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中 &#125;&#125; 六：数组，对于int类型，默认初值是0；对于string类型，默认初值是null；对于bool类型，默认初值是false。1.声明和基本使用。12345678910//数组类型[] 数组名=new 数组类型[数组长度];int[] nums=new int[10];//第二种数组声明方式直接声明初值int[] numsTwo = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;;for(int i = 0; i &lt; nums.Length; i++) //nums.Length就是数组的长度&#123; nums[i] = i; Console.WriteLine(nums[i]);&#125; 2.使用Array类实现数组升序和降序排序，Array.Sort方法可以实现数组的升序，而Array.Reverse的作用是将数组内元素反转，所以两种搭配起来可以实现降序。1234567int[] numsTwo = &#123; 1, 2, 3, 5, 4, 6, 8, 9, 7 &#125;;Array.Sort(numsTwo); //将数组内的元素升序排序Array.Reverse(numsTwo); //将数组内元素反转，配合上面的sort实现降序排序for(int i = 0; i &lt; numsTwo.Length; i++) //nums.Length就是数组的长度&#123; Console.WriteLine(numsTwo[i]); //输出9，8，7，6，5，4，3，2，1&#125; 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day3-分支、选择和循环结构","slug":"c-笔记day3","date":"2023-02-10T06:26:53.000Z","updated":"2023-02-18T14:55:24.696Z","comments":true,"path":"2023/02/10/c-笔记day3/","link":"","permalink":"http://example.com/2023/02/10/c-%E7%AC%94%E8%AE%B0day3/","excerpt":"","text":"c#笔记day3一：分支结构。1. if结构，先判断后执行，有可能不执行。 2.if-else结构，先判断后执行，else代表不满足if条件的其余所有情况，且else仅和离它最近的if配对。 3.if-else if-else结构，先判断if内容，再判断else if中，最后再判断else（所以有时else可以省略）。 二：异常捕获。如：输入abc等非数字类型就会抛异常。 12int a=Convert.ToInt32(Console.ReadLine()); //如果输入abc等非数字类型就会抛异常Console.WriteLine(a); 1.使用try和catch进行异常处理。1234567891011121314int a=0;bool flag = true;try&#123; a = Convert.ToInt32(Console.ReadLine()); //如果输入abc等非数字类型就会抛异常,然后立刻跳到catch块中 a = -a;&#125;catch&#123; //如果上面try块出现异常，则会跳到这里面执行 Console.WriteLine(&quot;有异常&quot;); flag = false;&#125;if(flag)&#123; Console.WriteLine(a);&#125; 三：选择结构。1.switch-case结构。 四：循环结构。1. while循环，如果循环括号内满足，则执行while循环中内容，执行一轮后，返回while循环，故如果一直满足循环的条件，可能会导致死循环。 2.for循环，正确执行后的顺序：表达式1-&gt;表达式2-&gt;循环体-&gt;表达式3-&gt;表达式2-&gt;…。注：表达式1声明循环变量必须存在（可以率先在外创建赋值），表达式2或3的条件可以不写； 3.break可以结束跳出离本层最近的for和while循环。4.而continue会跳出本轮的循环，进行下一轮循环（break是直接跳出全部的循环）。五：断点调试。（重要）1. 方法。（1）按F11键打开调试，然后再代码中每按一次F11都会执行下一行代码，左下角处的监视模块中你可以输入你想监视的变量值；（2）如下图中，黄色的行是当前待被调试的行，即下次按F11所要调试的行； （3）F10是逐过程调试，即调试方法时无需进入方法内部一步步如F11一样调试，内部会直接调试完成。例如：此时TellStory()是待调试的阶段，如果按F11会进入TellStory的方法中；而如果按F10，则会之间来到下一步，系统内部会自动完成对TellStory方法内部的过程。 2.断点：程序运行的中断处，后续运行就是要按F11进行调试。（1）鼠标点击左侧来添加断点，然后按F5进行正常运行，运行到断点处程序就会停止，接下来按F11正常调试即可。 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day2-基础","slug":"c-笔记day2","date":"2023-02-09T12:02:26.000Z","updated":"2023-02-13T09:40:52.337Z","comments":true,"path":"2023/02/09/c-笔记day2/","link":"","permalink":"http://example.com/2023/02/09/c-%E7%AC%94%E8%AE%B0day2/","excerpt":"","text":"c#笔记day2一：基本符号。1. +号的使用。12Console.WriteLine(5 + &quot;5&quot;); //输出的是55,这里+号起了连接作用Console.WriteLine(5 + 5); //输出的是10,这里+号起了运算作用 2.占位符{}，占位符内的0,1,2,…代表的是顺序。1234int a = 55, b = 56, c = 57;Console.WriteLine(&quot;第一个数字是&quot; +a+&quot;,第二个数字是&quot;+b+&quot;,第三个数字是&quot;+c); //未使用占位符，只能使用+进行连接Console.WriteLine(&quot;第一个数字是&#123;0&#125;,第二个数字是&#123;1&#125;,第三个数字是&#123;2&#125;&quot;, a, b, c); //使用了占位符&#123;&#125;，除文字外输出的具体数字顺序为55(a)，56(b)，57(c)Console.WriteLine(&quot;第一个数字是&#123;0&#125;,第二个数字是&#123;2&#125;,第三个数字是&#123;1&#125;&quot;, a, b, c); //使用了占位符&#123;&#125;，除文字外输出的具体数字顺序为55(a)，57(c)，56(b) 3.Console.ReadLine()接收用户输入，但只能以字符串string类型接收。12string name = Console.ReadLine(); //接收用户输入，但只能以字符串string类型接收Console.WriteLine(name); //输出用户方才输入内容 4.常用转义符：指的是用一个’\\‘+一个特殊的字符，组成一个具有特殊意义的字符。（1）\\n：表示换行。1Console.WriteLine(&quot;换行\\n&quot;); //转义符\\n写在字符串内 （2）\\“：表示一个英文半角的双引号。1Console.WriteLine(&quot;换行\\&quot;&quot;); //输出换行&quot; （3）\\t：表示一个tab键的空格，常用来手动对齐。1Console.WriteLine(&quot;换行\\t换行&quot;); //输出换行 换行 （4）\\b：表示一个退格键，文字需要两个\\b才有效果，而数字只需一个\\b，且放到字符串两边没有效果。123Console.WriteLine(&quot;换行\\b\\b换行&quot;); //输出换换行Console.WriteLine(&quot;换行6\\b换行&quot;); //输出换行换行Console.WriteLine(&quot;\\b换行6\\b换行\\b&quot;); //输出换行换行 （5）\\\\：表示一个\\，如果前面添加一个@符号，可以取消\\在字符串中的转义作用。12Console.WriteLine(&quot;输出\\\\&quot;); //输出\\Console.WriteLine(@&quot;输出\\\\&quot;); //输出\\\\ 二：类型转换。1.两种类型兼容，如int和double。（都为数字类型）（1）自动&#x2F;隐式类型转换（小–&gt;大）：int–&gt;double，改变不会加小数点。1234int n1 = 10;int n2 = 3;double d = n1 / n2;Console.WriteLine(d); //输出3，而不是3.0，因为右侧n1/n2结果就是整数，赋给左边是隐式类型转换，但不会改变值 （2）显示&#x2F;强制类型转换（大–&gt;小）：double–&gt;int，将某个操作数提升为double类型，整体都会成为double类型。1234int n1 = 10;int n2 = 3;double d = n1*1.0 / n2; //整数乘1.0就可以提升为double类型Console.WriteLine(d); //输出3.33333 （3）同种类型，也也可以直接在括号中填写要转换的类型，如(int)、(double)。1234int a = 10;int b = 3;double c = (double)a / b; //同种类型，也可以直接在括号中填写要转换的类型Console.WriteLine(c); //输出3.33333 （4）double保留小数点位数，只需要在占位符后面加上:0.00，但是只是输出时保留，原变量值并没有保留。（看点号后零的个数，这决定小数点位数）12345int n1 = 10;int n2 = 3;double a = n1*1.0 / n2; //整数乘1.0就可以提升为double类型double b = 2;Console.WriteLine(&quot;&#123;0:0.00&#125;,&#123;1:0.00&#125;&quot;,a,b); //输出3.33,2.00 补充解决方法：使用字符串保留n位小数，然后转成double。 123456789static void Main(string[] args)&#123; double a = 10*1.0/3; string s=a.ToString(&quot;0.00&quot;); //string类型保留double的两位小数 Console.WriteLine(s); //输出3.33 a=Convert.ToDouble(s); //让double的值变为保留两位小数 Console.WriteLine(a); //输出3.33 Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中&#125; 2.两种类型不兼容。(1)Convert类型转换，在类型不兼容情况下使用Convert.ToXXX进行转换（如string–&gt;double），Convert类的方法很多，如ToDouble、ToDateTime、ToInt32等。12345string s = &quot;123&quot;;double d=Convert.ToDouble(s); //将字符串类型转换为double类型Console.WriteLine(d); //输出123int n = Convert.ToInt32(s); //将字符串类型转换为int类型Console.WriteLine(n); //输出123 （2）使用int类的方法，如int.Parse或int.TryParse（推荐）实现由字符串到数字类型的转换。1234int a=0;bool b=int.TryParse(Console.ReadLine(), out a); //将括号左边的字符串类型转换成整数放到右边的变量中，整体输出的int.TryParse是bool型Console.WriteLine(b); //如果输入内容不是整数，则不会报异常会输出false，比int.Parse和Convert.ToInt32安全Console.WriteLine(a); //a中是转换后的内容 三：简单运算符。1. 一元运算符，++（自增）、- -（自减），优先级大于+、-、*、&#x2F;。（1）++和–都分为前++、后++或前- -后- -，所得到的内容是不同的，前++是先+1后运算，而后++是先运算再+1。（–同理）前++： 1234int number = 10;int result = ++number + 10; //++number是先+1再运算，故此次++number + 10=21Console.WriteLine(number); //输出11Console.WriteLine(result); //输出21 后++： 1234int number = 10;int result = 10 + number++ ; //number++是先运算再+1，故此次10+ number++=20Console.WriteLine(number); //输出11Console.WriteLine(result); //输出20 2.关系运算符。（1）bool变量和&#x3D;&#x3D;关系运算符。1234bool result = 3 &gt; 1000;bool a = 20 == 30; // ==是关系运算符，表示问是否相等Console.WriteLine(result); //输出FalseConsole.WriteLine(a); //输出False 2. 逻辑运算符。（两边一般都是关系表达式或bool类型的值）（1）&amp;&amp;–&gt;与，有0出0，全1出1。123bool result = 3 &gt; 1000; //result为Falsebool a = 20 == 30; //a为FalseConsole.WriteLine(result &amp;&amp; a); //与是有0出0，两个全为False，所以输出False （2）||–&gt;或，有1出1，全0出0。123bool result = 3 &gt; 1000; //result为Falsebool a = 20 == 30; //a为FalseConsole.WriteLine(result || !a); //或有1出1，result为False，而!a为True，所以输出True （3）！–&gt;非，取反，1变0，0变1。123bool result = 3 &gt; 1000; //result为Falsebool a = 20 == 30; //a为FalseConsole.WriteLine(result || !a); //或有1出1，result为False，而!a为True，所以输出True （4）判断闰年题：闰年是能被400整除或能被4整除但不能被100整除的年份。1234Console.WriteLine(&quot;请输入年份!&quot;);int year = Convert.ToInt32(Console.ReadLine());bool a=(year%400==0)||(year%4==0)&amp;&amp;(year%100!=0); //判断闰年Console.WriteLine(a); 4.复合逻辑运算符。（1）+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;。123int a = 10;a += 20; //即a=a+20，其余-、*、/同理Console.WriteLine(a); //输出30 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"c#笔记day1-基础","slug":"c-笔记day1","date":"2023-02-08T12:09:42.000Z","updated":"2023-02-21T14:53:23.197Z","comments":true,"path":"2023/02/08/c-笔记day1/","link":"","permalink":"http://example.com/2023/02/08/c-%E7%AC%94%E8%AE%B0day1/","excerpt":"","text":"c#笔记day1一：认识c#代码的组成部分。 二：Main中的两行代码，Console.WriteLine输出会自动换行，而Console.Write输出不会换行。12345static void Main(string[] args)&#123; Console.WriteLine(&quot;Hello World&quot;); //在控制台的一行中输出内容：Hello World Console.ReadKey(); //暂停当前程序，等待用户按下任意键继续，按下的任意键将显示在控制台中(默认参数为false) Console.ReadKey(true); //暂停当前程序，等待用户按下任意键继续，按下的任意键不显示在控制台中&#125; 三：VS的基本设置。1. 对于项目较多时，如果你不想项目存在，但是又不想删除，可以右键将其暂时卸载，后续恢复也是按右键选择恢复。 2.运行可以按F5，也可以点击上方的绿色三角形，左侧可以选择要运行的项目；调试按键是F11，停止运行可以按红色正方形。 3.常用快捷键。 （1）Ctrl+K+D自动代码对齐，鼠标点到代码，然后一直按着Ctrl，然后按K，松开按D即可（不能K和D一起按，必须保证按D的时候，K已经松开）。（2）#Region和#EndRegion，可以实现折叠冗余代码。（注意#Region后面加一个空格，然后就可以填写注释内容）（3）F1打开官方文档查看也很重要，不会的代码，可以选中按F1。（4）对齐代码时，TAB键可以实现跳格，而与之相反的是SHIFT+TAB键。四：注释。1. 单行注释 &#x2F;&#x2F;。2. 多行注释 &#x2F;*要注释的内容*&#x2F;。3. 文本注释 &#x2F;&#x2F;&#x2F; 多用来解释类或方法。 五：变量。1.存储变量的语法：变量类型 变量名; 变量名&#x3D;值; 简写：变量类型 变量名&#x3D;值; 注：此处的’&#x3D;’号，不表示等于的意思，表示的是赋值的意思，即把等号右边的值赋值给等号左边的变量。 2.数据类型。（1）整数类型：int。（2）小数类型：double或float，但float后面要加一个后缀f&#x2F;F，如float x&#x3D;3.56f。（3）金钱类型：decimal，记得值后面需要加上一个m，如decimal money&#x3D;500m。（4）字符串类型：string，可以存储空，以英文半角状态下的双引号括起来。（5）字符类型：char，不能存储空，以英文半角状态下的单引号括起来。3.变量命名。（1）以字母、下划线或@开头，不要以数字开头；后面可以跟字母、数字、下划线(不能跟空格)，也不能出现特殊符号。（2）Camel命名法(对变量命名)：第一个单词的首字母小写，后续单词的首字母都大写。（3）Pascal命名法(对方法或类命名)：每个单词的首字母都大写。 4.变量交换。（1）如交换a、b两个变量的值，可以用一个中间变量进行过渡。1234567int a = 10;int b = 20;int temp; //中间变量temp = a;a = b;b = temp;Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;,a,b); //输出的a、b分别是20和10 （2）可以用加减方法实现交换：a&#x3D;a-b,b&#x3D;a+b,a&#x3D;b-a。123456int a = 10;int b = 20;a = a - b;b = a + b;a = b - a;Console.WriteLine(&quot;&#123;0&#125;,&#123;1&#125;&quot;,a,b); //输出的a、b分别是20和10 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"}],"author":"JCM"},{"title":"VS2022和Github代码仓库的上传同步教程","slug":"VS2022和Github代码仓库的上传同步教程","date":"2023-02-08T07:24:51.000Z","updated":"2023-02-18T15:45:31.035Z","comments":true,"path":"2023/02/08/VS2022和Github代码仓库的上传同步教程/","link":"","permalink":"http://example.com/2023/02/08/VS2022%E5%92%8CGithub%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E7%9A%84%E4%B8%8A%E4%BC%A0%E5%90%8C%E6%AD%A5%E6%95%99%E7%A8%8B/","excerpt":"","text":"VS2022和Github代码仓库的上传同步1.使用visual studio，具体下载安装过程就不说了，新建项目，然后创建源代码模板进来后，点击右下角的添加到源代码管理，选择git。 2.进来后，把下面的信息github 相连即可，然后创建并推送，然后就会在github你的存储库中创建成功。 3.在vs中，右下角就会发生变化。 4.点击右下角的小笔，然后右边栏就会变为Git更改。 5.修改代码后，由vs上传到github上。（1）如果我对正文的程序段进行了修改，右下角小笔数字就会变化。（2）然后如果要上传修改到github上，先在下面的2区域中填上备注，然后点击全部提交。（3）在点击下面4区域的上传箭头（推送），就可以同步到github上。 6. 在github上修改，然后由github同步到vs上。（1）在github中，点击小笔修改内容，写完保存。 （2）然后在vs中点击向下的箭头（拉取），就可以自动把github中的内容同步到vs中了！ 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"}],"author":"JCM"},{"title":"Makedown语法学习教程","slug":"Makedown语法学习教程","date":"2023-02-07T01:42:21.000Z","updated":"2023-02-12T15:15:44.045Z","comments":true,"path":"2023/02/07/Makedown语法学习教程/","link":"","permalink":"http://example.com/2023/02/07/Makedown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B/","excerpt":"","text":"Typora-结构类操作一：多级标题。(2个知识点)1.一种是’#’+‘ ’（空格）+“XXX”;2.另一种就是快捷键的ctrl+1~6方式对应生成相应等级标题。注：快捷键仅能在Typora等软件中使用，因为你可以在软件上方栏的段落中看到。 3.文字居中，只需要设置相应文字格式后，在前面加个’&lt;’+”center”+’&gt;’（就是center左右两个尖括号）即可。 二：有序列表。(3个知识点)1.使用1（序号）+’.’+’ ‘+”XXX”，然后回车会自动加序号，中间添加或删除也会自动加减序号，而向下键无法自动调整序号；2.可以通过Tab和Shift+Tab实现列表的升降级；3.快捷键 Ctrl+Shift+[ 也可以快速生成列表格式（选中原有文字，然后按快捷键即可）。 三：无序列表。(4个知识点)1.使用’*’+’ ‘+”XXX”或’-‘+’ ‘+”XXX”来实现；2.同样可以使用Tab和Shift+Tab实现列表的升降级；3.有序列表和无需列表可以交错使用；4.无序列表的快捷键 Ctrl+Shift+] ，刚好和有序列表相反。 四：任务列表。(2个知识点)1.使用’-‘+’ ‘+’[‘+’ ‘+’]’+’ ‘+”XXX”来实现，注意中间的空格，最终任务列表前面的框我们可以手动打上勾。2.也可以选中写的文字，使用快捷键Ctrl+Shift+X实现。 五：插入表格。(4个知识点)1.通过|来进行表格创建，也可以使用快捷键Ctrl+T；2.添加行，通过Ctrl+回车；3.也可以在表格上面的选项中执行对齐、改变表格行列、插入删除行列和删除表格操作；(下图是PPT中，所以没有，但是在Typora中有)4.也可以在表格中按鼠标右键选择对应的操作。 Typora-代码类操作六：行内代码。(2个知识点)1.使用键盘的反引号&#96;，这是在英文输入法状态下的，如果是按Shift，就会变为~，所以要注意；2.也可以选择对应代码，按下快捷键Ctrl+Shift+&#96;。 七：代码块。(3个知识点)1.输入3个&#96;或三个~，再后面跟上对应的语言；2.建议提前在偏好设置中设置显示行号和自动换号，然后重启Typora生效；3.快捷键是Ctrl+Shift+K，可能会与搜狗输入法中打开键盘的快捷键冲突，故可以右键搜狗输入法，进入设置，在设置中把重合的快捷键关闭掉。 Typora-元素类操作八：上传图片。注：前往本网站的PicGo图片上传教程。 Typora-其他补充操作九：分割线。(1个知识点)1.输入三个*，或三个以上-，然后按回车即可。 十：字体。(1个知识点)1.如下图，左右两侧不同数量的*或_就是不同的字体。 十一：删除线、下划线和脚注。(3个知识点)1.删除线的格式就是左右两侧两个~~；2.下划线的格式就是一个u标签；3.脚注的内容先用[]括起来，最前面加上^，后面要有一个空格，最下方以同样的格式对其进行介绍。(非注释中[^]不能放在开头) 十二：区块引用。(3个知识点)1.使用’&gt;’+’ ‘+”XXX”使用区块引用，例如文章最后的请勿转载提示，就可以写在区块引用上。2.区块引用使用多个&gt;可以进行嵌套。3.区块引用和列表也可以互相嵌套。 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Makedown","slug":"Makedown","permalink":"http://example.com/tags/Makedown/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"JCM"},{"title":"PicGo图片上传教程","slug":"PicGo图片上传教程","date":"2023-02-07T01:37:46.000Z","updated":"2023-02-12T15:20:43.341Z","comments":true,"path":"2023/02/07/PicGo图片上传教程/","link":"","permalink":"http://example.com/2023/02/07/PicGo%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E6%95%99%E7%A8%8B/","excerpt":"","text":"PicGo图片上传教程一：下载安装。1.百度搜索picgo，然后进入github，网站： 2.进入github相应网站，然后点击右下角releases。 3.打开下载地址，对应电脑版本下载即可，我是x64版本。 4. 下载完，然后打开安装包安装即可。二：配置。1.打开后，在电脑右下角会显示，从中进入。 2.软件示例。 3.可以点开PicGo设置，选择你要使用的图床。（我用的是SM.MS，如果购买了腾讯云或阿里云使用那个更快些，GitHub可能比较慢，而且配置容易出错） 4.然后，在图床设置中选择Default进行编辑，需要获取对应的Token，我这里需要SM.MS的Token。 5.打开网址，点击右上角User登录注册。 6.注册登录后，点击User下的Dashboard。 7.然后点击左侧栏的API Token，然后点击Generate Secret Token即可，把上面的Secret Token复制到PicGo里面，然后把备用上传域名填上。 8.然后就选择对应的链接格式上传了。 9.上传成功后，在左侧的相册中就可以查看上传后的地址，也可以删除。（注意，复制地址时的格式，要在前面上传区的下面先选择好！比如我要复制的是URL，则要在上传区下面选择URL） 10.如果要把URL删除，在PicGo上删除的只是记录，而传上去的还在，所以要到SM.MS里面进行管理删除。 11.也可以不使用PicGo，通过SM.MS内部手动上传。 三：Typora连接PicGo，上传图片。1.先进入Typora软件，打开偏好设置。 2.点击左侧里面的图像，然后对下边进行配置，如果没有下载PicGo要先下载。 3.然后就可以使用了，举例：我们随便输字，然后截图。 截图： 4.直接复制粘贴这张图片到Typora中，它会自动转为Markdown格式并自动上传，然后看提示是否上传成功。 5.提示上传成功即可。 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"SM.MS","slug":"SM-MS","permalink":"http://example.com/tags/SM-MS/"}],"author":"JCM"},{"title":"零基础搭建博客教程","slug":"零基础搭建博客教程","date":"2023-02-06T03:34:22.000Z","updated":"2023-02-18T15:40:19.660Z","comments":true,"path":"2023/02/06/零基础搭建博客教程/","link":"","permalink":"http://example.com/2023/02/06/%E9%9B%B6%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/","excerpt":"","text":"零基础搭建博客教程一：安装程序。1.Node.js。（1）打开官网下载链接，我这里下载的是node-v6.9.2-x64.msi,如下图： （2）安装。1.下载完成后，双击“node-v6.9.2-x64.msi”，开始安装Node.js。 2.点击【Next】按钮。 3.勾选复选框，点击【Next】按钮。 4.修改好目录后，点击【Next】按钮。 5.安装完后点击【Finish】按钮完成安装。 （3）cmd查看。1.至此Node.js已经安装完成，可以先进行下简单的测试安装是否成功了，后面还要进行环境配置。在键盘按下【win+R】键，输入cmd，然后回车，打开cmd窗口。 2.输入node-v显示node.js的版本说明安装成功，输入npm -v，如果显示npm版本说明自带的npm也安装成功。 3.然后进入对应安装位置的node.js目录，其中再新建node_cecal和node_global这两个空文件夹。 （4）环境配置。1.说明：这里的环境配置主要配置的是npm安装的全局模块所在的路径，以及缓存cache的路径，之所以要配置，是因为以后在执行类似：npm install express [-g] （后面的可选参数-g，g代表global全局安装的意思）的安装语句时，会将安装的模块安装到【C:\\Users\\用户名\\AppData\\Roaming\\npm】路径中，占C盘空间。故：我希望将全模块所在路径和缓存路径放在我node.js安装的文件夹中，则在我安装的文件夹【E:\\node.js】下创建两个文件夹【node_global】及【node_cache】如下图： 2.创建完两个空文件夹之后，打开cmd命令窗口，输入npm config set prefix “文件路径\\node_global”和npm config set cache “文件路径\\node_cache”。 3.接下来设置环境变量，关闭cmd窗口，“我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”。 4.在系统变量中新建下面一项，注意路径是自己安装的目录，如我这里是XXX路径\\node_modules。 5.编辑环境变量Path。将下面这条修改为XX路径\\node_global。 修改后： （5）测试。输入npm install express -g，然后提示安装成功即可。（提示界面不同没关系，看到安装成功就行） （6）具体参考网站：https://www.cnblogs.com/liuqiyun/p/8133904.html 2.Git。1.获取Git安装程序，点此。 因为我们是用Windows系统上的浏览器访问的，Git官网自动之别到了我使用的操作系统，所以右侧直接显示下载使用Windows系统的最新版本（如果识别错误，可以在中间选择系统），点击即可下载。我下载的是 2.24.0 for Windows，文件名称是“Git-2.24.0.2-64-bit.exe”。下载到电脑上之后，鼠标双击这个文件即可进入安装过程。 （2）Git安装过程。双击看到的第一个界面如下图： 1.使用许可声明。 点击“Next”进入下图页面： 2.选择安装路径。 在输入框内输入想要安装到的本机路径，也就是实际文件夹位置，或点击“Browse…”选择已经存在的文件夹，然后点击“Next”按钮继续，进入下图界面： 3.选择安装组件。 上图红框内的选项是默认勾选的，建议不要动。绿色框1是决定是否在桌面创建快捷方式的。绿色框2是决定在所有控制台窗口中使用TrueType字体和是否每天检查Git是否有Windows更新的。这些根据自己需要选择。 点击“Next”按钮进入下图界面： 4.选择开始菜单页。 这个界面是创建开始菜单中的名称，不需要修改，直接点“Next”按钮继续到下图的界面： 5.选择Git文件默认的编辑器。 这个页面是在选择Git文件默认的编辑器，很少用到，所以默认Vim即可，直接点“Next”按钮继续到下图的界面： 6.调整您的PATH环境。 这个界面是调整您的PATH环境。 第一种配置是“仅从Git Bash使用Git”。这是最安全的选择，因为您的PATH根本不会被修改。您只能使用 Git Bash 的 Git 命令行工具。但是这将不能通过第三方软件使用。 第二种配置是“从命令行以及第三方软件进行Git”。该选项被认为是安全的，因为它仅向PATH添加了一些最小的Git包装器，以避免使用可选的Unix工具造成环境混乱。 您将能够从Git Bash，命令提示符和Windows PowerShell以及在PATH中寻找Git的任何第三方软件中使用Git。这也是推荐的选项。 第三种配置是“从命令提示符使用Git和可选的Unix工具”。警告：这将覆盖Windows工具，如 “ find 和 sort ”。只有在了解其含义后才使用此选项。 我选择推荐的选项第二种配置，点击“Next”按钮继续到下图的界面： 7.选择HTTPS后端传输。 这个界面是选择HTTPS后端传输。 第一个选项是“使用 OpenSSL 库”。服务器证书将使用ca-bundle.crt文件进行验证。这也是我们常用的选项。 第二个选项是“使用本地 Windows 安全通道库”。服务器证书将使用Windows证书存储验证。此选项还允许您使用公司的内部根CA证书，例如通过Active Directory Domain Services 。 我使用默认选项第一项，点击“Next”按钮继续到下图的界面： 8.配置行尾符号转换。 这个界面是配置行尾符号转换。 第一个选项是“签出Windows风格，提交Unix风格的行尾”。签出文本文件时，Git会将LF转换为CRLF。提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Windows上的推荐设置（“ core.autocrlf”设置为“ true”） 第二个选项是“按原样签出，提交Unix样式的行尾”。签出文本文件时，Git不会执行任何转换。 提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Unix上的建议设置（“ core.autocrlf”设置为“ input”） 第三种选项是“按原样签出，按原样提交”。当签出或提交文本文件时，Git不会执行任何转换。不建议跨平台项目选择此选项（“ core.autocrlf”设置为“ false”） 我选择第一种选项，点击“Next”按钮继续到下图的界面： 9.配置终端模拟器以与Git Bash一起使用。 这个界面是配置终端模拟器以与Git Bash一起使用。 第一个选项是“使用MinTTY（MSYS2的默认终端）”。Git Bash将使用MinTTY作为终端模拟器，该模拟器具有可调整大小的窗口，非矩形选择和Unicode字体。Windows控制台程序（例如交互式Python）必须通过“ winpty”启动才能在MinTTY中运行。 第二个选项是“使用Windows的默认控制台窗口”。Git将使用Windows的默认控制台窗口（“cmd.exe”），该窗口可以与Win32控制台程序（如交互式Python或node.js）一起使用，但默认的回滚非常有限，需要配置为使用unicode 字体以正确显示非ASCII字符，并且在Windows 10之前，其窗口不能自由调整大小，并且只允许矩形文本选择。 我选择默认的第一种选项，点击“Next”按钮继续到下图的界面： 10.配置额外的选项。 这个界面是配置额外的选项。 第一个选项是“启用文件系统缓存”。文件系统数据将被批量读取并缓存在内存中用于某些操作（“core.fscache”设置为“true”）。 这提供了显著的性能提升。 第二个选项是“启用Git凭证管理器”。Windows的Git凭证管理器为Windows提供安全的Git凭证存储，最显着的是对Visual Studio Team Services和GitHub的多因素身份验证支持。 （需要.NET Framework v4.5.1或更高版本）。 第三个选项是“启用符号链接”。启用符号链接（需要SeCreateSymbolicLink权限）。请注意，现有存储库不受此设置的影响。 我勾选默认的第一、第二选项，点击“Next”按钮继续到下图的界面： 11.配置实验选项。 这个界面是配置实验选项。 启用实验性的内置添加 -i &#x2F; -p。（新！）使用实验性的内置交互式add（“ git add -i”或“ git add -p”）。这使其速度更快（尤其是启动！），但尚未被认为是可靠的。 默认不勾选，直接点击“Next”按钮继续到下图的安装进度界面： 12.安装进度指示。 安装进度结束之后，会出现下图的完成Git安装向导界面： 13.安装完成。 在这个界面，可以勾选是否启动启动Git Bash和是否查看发行说明，然后点“Finish”按钮退出安装界面。 （3）测试。 （4）具体参考网站：https://www.cnblogs.com/xueweisuoyong/p/11914045.html 3.Hexo。（1）直接在cmd中输入npm install hexo-cli -g，安装即可。（提示界面不同没关系，看到安装成功就行） （2）测试是否安装成功，输入npx hexo version，成功即可。 二：Github注册仓库。1. 注册github账号。（1）我们首先需要注册这个github号，进入网址，点此。 （2）进入看到的是如上页面。接下来点击右上角sign up。 （3）进来之后就开始注册你的信息了。1.注册。 2.在这里选择左边这个免费的。 3.进入qq邮箱，点击github发给你的消息，以此确定完成了你的github注册功能！！！ 4.我们现在回到页面，点击右上角Sign in来进行登录我们的github，输入账号密码即可。 （4）具体参考网站：https://www.bilibili.com/read/cv5107169/ 2.创建repository。（1）点击右上角账号，点击your repositories。 （2）点击new新建。 （3）输入Repository.name，需要注意的是需要填的内容XXX要与Owner的名字相同，例如XXX.github.io。 （4）下面的选择Public和Add a README file即可，其余多的都不需要，然后点击Create repository创建。 （5）创建repository成功。 （6）参考视频地址：https://www.bilibili.com/video/BV1mU4y1j72n?p=2&amp;vd_source=c1ef3b7a869d417b009bf7c080cd53cf 3.生成SSH Keys。（1）先随便进入电脑中的一个文件夹中（必须是一个文件夹中），右键选择Git Bash Here。 （2）先输入ssh，看到下面生成一串字符即可。 （3）输入ssh-keygen -t rsa -C “邮箱地址”，然后按四次回车即可。 （4）然后到电脑C盘的目录中去找.ssh文件夹中的id_rsa.pub，我这里是这个地方。 或者：右上角直接搜id_rsa.pub，但是如果C盘内容多，搜索慢。 （5）以记事本或其他软件打开，然后ctrl A+ctrl C复制即可。（无须改动里面的内容和格式） （6）重新回到github中，点击右上角头像，找到下面的Settings进入。 （7）进入后，在左侧栏中找到SSH and GPG keys这一项点击。 （8）然后点击New SSH key新建秘钥。 （9）填写内容，Title内随便写，Key中把刚刚复制来的内容放进去即可，无须改动内容和格式，然后点击Add SSH key即可。 （10）测试，在git中输入ssh -T &#103;&#105;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#99;&#111;&#109;，提示成功即可。 （11）参考视频地址：https://www.bilibili.com/video/BV1mU4y1j72n?p=3&amp;vd_source=c1ef3b7a869d417b009bf7c080cd53cf 4.hexo本地生成博客内容。（1）在本地，随便选一个地方新建一个文件夹（名字随意，我这里是MyBlog），进入文件夹。 （2）同理，在空文件内右键点击Git Bash Here。 （3）先输入npm install -g hexo，重新安装一下，确保后续可行性。 （4）输入npx hexo init XXX（XXX内里的内容随便都行，我写的是github的用户名），然后就可以发现对应目录中生成了文件夹，打开里面就是hexo模板内容。 （5）然后cd XXX进入文件夹中，然后输入npx hexo s，即可打开本地的服务器的端口，下面显示http://localhost:4000，可以复制网址到浏览器中打开。 打开后就是模板： Git中按ctrl+C就可以关闭对应的端口，网页地址也就不能访问，下次想访问，再到这个文件夹内使用git输入npx hexo s即可。 （6）参考视频地址：https://www.bilibili.com/video/BV1mU4y1j72n?p=4&amp;vd_source=c1ef3b7a869d417b009bf7c080cd53cf 5.同步本地内容到github上，并发布博客到互联网中。（1）打开前面创建的本地博客文件夹，找到_config.yml文件，以记事本或其他软件打开。 （2）拉到最下面进行配置，添加deploy里面的内容，里面的type: git（type:后面有一个空格，即git前有一个空格）,branch: main（branch:后面有一个空格，即main前有一个空格），repository内容见文章后面。 （3）repository的内容，需要我们先进入前面创建的repository中，点击Code，然后把下面的内容复制进去即可。（注意形式和上面的type和branch一样，英文的冒号后面都有一个空格） （4）然后退出_config的编辑，在文件夹右键打开Git Bash Here，输入npm install hexo-deployer-git –save安装。 （5）再输入npx hexo g，生成镜像文件。 （6）之后就是部署内容到github上的环节，此次出错很多。输入npx hexo d，如下我就报错了。 （7）根据报错提示，再输入git config –global user.email “电子邮件内容”和git config –global user.name ”github用户名”。 (8)然后找到.deploy_git点击进入，我这里面有一个隐藏文件夹，点击上面的查看，把隐藏的项目点上。 (9)然后发现里面有一个隐藏的.git文件夹，进入找到config文件，用记事本或其他软件编辑。 找到工程目录的.git文件夹，打开之后找到config文件，在最后边加上一句话：[user]email&#x3D;your emailname&#x3D;your name (10)再运行npx hexo d，发现还是报错，提示unable to access，且SSL certificate problem:unable to get local issuer certficate。 (11)再输入git config –global http.sslVerify false和git push来接触SSL验证。 (12)最后再运行npx hexo d，会跳出一个类似登录界面，然后点击view in browse进入下面的浏览器，连接成功后，github项目中的内容也成功备份进来了。 (13)进入网址，先点击Settings，然后再左侧找到Pages，里面就可以找到网址，浏览器进入即可。 （14）剩下的就是blog的美化和样式整理，文件可以在本地修改，然后使用npx hexo d上传更新到git上即可。三：参考文献。1.【2021最新版】保姆级Hexo+github搭建个人博客：https://www.bilibili.com/video/BV1mU4y1j72n?p=1&amp;vd_source=c1ef3b7a869d417b009bf7c080cd53cf 2.hexo搭建个人博客超简单效果超好的个人网站博客搭建对小白很友好：https://www.bilibili.com/video/BV1Rt4y1k7it?p=1&amp;vd_source=c1ef3b7a869d417b009bf7c080cd53cf 3.【零基础】保姆级搭建个人博客hexo：https://www.bilibili.com/video/BV1WB4y1G7eW/?spm_id_from=333.788&amp;vd_source=c1ef3b7a869d417b009bf7c080cd53cf 4.hexo博客matery主题的个性化配置：https://blog.csdn.net/qq_41376237&#x2F;article&#x2F;details&#x2F;113475727?app_version&#x3D;5.10.0&amp;code&#x3D;app_1562916241&amp;csdn_share_tail&#x3D;%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22113475727%22%2C%22source%22%3A%22qq_74845080%22%7D&amp;uLinkId&#x3D;usr1mkqgl919blen&amp;utm_source&#x3D;app 四：写文章。1.在对应的根目录下（例如E:\\MyBlog\\jcm111859242）生成新文章，也是右键打开Git Bash Here，然后输入hexo new “文章名”生成。 2. 打开编写即可，但是Markdown类型文件最好下载一个编辑器，如Typora，下载参考：https://www.bilibili.com/video/BV14x4y137Kd/?spm_id_from=333.337.search-card.all.click&amp;vd_source=c1ef3b7a869d417b009bf7c080cd53cf 百度网盘： 链接：https://pan.baidu.com/s/1oE2SV06RolBLSJdyY0_LNw 提取码：svz3 （1）点击安装。 （2）安装时记得把下面这个勾上。 （3）右键安装后的Typora，打开文件所在位置，然后把安装包里面的winmm.dll压缩到这个里面即可。 （4）打开即可，发现已经破解，后续就可以正常使用。 3.对于Markdown类型，需要学习相关语法，点此。五：主题美化。1. 可以自己到官网或其他地方寻找hexo的主题，以volantis为例子，先到官网寻找。（1）搜索打开hexo官网，在主题中搜索volantis。 （2）进入浏览，我们可以点击源码，进入安装的github教程模块。 （3）进入官网，根据教程，需要找到hexo根目录下的_config.yml，将里面的theme后面内容改为volantis，然后再外面右键使用Git Bash Here，输入npm i hexo-theme-volantis安装。 （4）然后本地调试，输入npx hexo s，打开网址，就发现改成volantis格式了。 2.具体配置详见官方文档：https://volantis.js.org/v6/getting-started/ （1）简单的配置可以根据视频：https://www.bilibili.com/video/BV1GP4y1d729/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=c1ef3b7a869d417b009bf7c080cd53cf （2）为博客增加樱花特效和鼠标点击特效，在下面的文件目录中找到layout.ejs，然后添加下面的代码即可。 1234&lt;!-- 樱花特效 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/yremp/yremp-js@1.5/sakura.js&quot;&gt;&lt;/script&gt;&lt;!-- 点击出现社会主义彩色文字 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/shehuizhuyi.js&quot;&gt;&lt;/script&gt;&lt;!-- 点击出现爱心 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/love.js&quot;&gt;&lt;/script&gt;&lt;!-- 点击出现彩色气球爆炸效果 --&gt;&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/gh/wallleap/cdn/js/clickBom.js&quot;&gt;&lt;/script&gt; 3.添加天气栏目。（1）我们使用心知天气，点此进入，先注册登录后，然后点击立即免费试用。 (2)然后创建插件，自行选择。 (3)点击生成代码，然后把上面JS块先复制。 (4)然后进入你主题文件夹中（我这里主题文件夹是hexo-theme-volantis），然后进入layout&#x2F;_partial中，找到header.ejs。 (5)然后复制到里面，我这里是复制到m_search上面，因为网页中布局放那里比较好。 (6)然后要在hexo的根目录的_config.yml中添加xinzhi_weather: true，就可在网页上看到效果。 本文为作者原创，请勿随意抄袭转载。","categories":[{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}],"author":"JCM"}],"categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"},{"name":"教程","slug":"教程","permalink":"http://example.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://example.com/tags/Visual-Studio/"},{"name":"c#","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"unity","slug":"unity","permalink":"http://example.com/tags/unity/"},{"name":"Github","slug":"Github","permalink":"http://example.com/tags/Github/"},{"name":"Makedown","slug":"Makedown","permalink":"http://example.com/tags/Makedown/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"PicGo","slug":"PicGo","permalink":"http://example.com/tags/PicGo/"},{"name":"SM.MS","slug":"SM-MS","permalink":"http://example.com/tags/SM-MS/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]}